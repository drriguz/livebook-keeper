<html>
 <head></head>
 <body>
  <div class="readable-text" refid="1" id="1" data-hash="3fb5041da2551d1716ee86af1e66526e"> 
   <h1 class="chaptertitle" id="heading_id_22">2 <a class="pcalibre pcalibre1" id="verticles-the-basic-processing-units-of-vert-x" shape="rect"></a>Verticles: the basic processing units of Vert.x</h1> 
  </div> 
  <div class=" introduction-summary"> 
   <h3 class="intro-header">This chapter covers:</h3> 
   <ul> 
    <li class=" readable-text" refid="2" id="2" data-hash="872922454601587afcf7daed2679476f"> What verticles are,<br> </li> 
    <li class=" readable-text" refid="3" id="3" data-hash="9f8cf4bae42f9054930816d356a13957"> How to write, configure and deploy verticles,<br> </li> 
    <li class=" readable-text" refid="4" id="4" data-hash="f2e87fedcdb41328e436a1a166e31fa5"> The Vert.x threading model,<br> </li> 
    <li class=" readable-text" refid="5" id="5" data-hash="bcb8372bb55f8b04266c3a14348cd14a"> How to mix Vert.x and non-Vert.x threads.<br> </li> 
   </ul> 
  </div> 
  <div class="readable-text" refid="6" id="6" data-hash="4628690734e444abc01e0fcc63489ae7"> 
   <p>Put simply, a <em class="calibre10">verticle</em> is the fundamental processing unit in Vert.x. The role of a verticle is to encapsulate a <em class="calibre10">technical functional unit</em> for processing events such as exposing a HTTP API and responding to requests, providing a repository interface on top of a database, or issuing requests to a third-party system. Much like components in other technologies like <em class="calibre10">Enterprise Java Beans</em>, verticles can be deployed, and they have a life-cycle.</p> 
  </div> 
  <div class="readable-text" refid="7" id="7" data-hash="af974a730b85913638edf321a6181379"> 
   <p>Readers familiar with the <em class="calibre10">actor concurrency model</em> will find similarities between Vert.x verticles and actors <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/ActorModel" shape="rect">[ActorModel]</a>. Put simply, actors are a model where autonomous entities (the actors) exclusively communicate with other entities by sending and responding to messages. The similarities between Vert.x verticles and actors is no fortuitous coincidence: verticles have private state that may be updated when receiving events, they can deploy other verticles, and they can communicate via message-passing (more on that in the next chapter). Verticles do not necessarily follow the orthodox modern definition of actors, but it is fair to consider Vert.x at least as being inspired by actors.</p> 
  </div> 
  <div class="readable-text" refid="8" id="8" data-hash="d218ec5c8b9b63ae4987110a5a40dda3"> 
   <p>Let us now dive into writing verticles.</p> 
  </div> 
  <div class="readable-text" refid="9" id="9" data-hash="ebc570b87a87b283b56e5f0ab36914b7"> 
   <h2 class="calibre17" id="heading_id_3"><a class="pcalibre pcalibre1" id="writing-a-verticle" shape="rect"></a>2.1 &nbsp;Writing a verticle</h2> 
  </div> 
  <div class="readable-text scrambled" refid="10" id="10" data-hash="c2ce16dfcbbe2d5d89881a5e2cb30c12"> 
   <p>Since verticles are a key concept in Vert.x, we will look into how they work. Before that, let us write a small verticle that processes 2 types of events: periodic timers and HTTP requests.</p> 
  </div> 
  <div class="readable-text" refid="11" id="11" data-hash="a96ac9523969ccf814339d604337bfc8"> 
   <h3 class="calibre29" id="heading_id_4"><a class="pcalibre pcalibre1" id="preparing-the-project" shape="rect"></a>2.1.1 &nbsp;Preparing the project</h3> 
  </div> 
  <div class="readable-text scrambled" refid="12" id="12" data-hash="b617c27f1ae2c765aadaf681f670a4eb"> 
   <p>We will use a common project for all samples in this chapter, using the Gradle project descriptor of listing 2.1.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="13" id="13" data-hash="861b6256eca927fefdea4a21cecb77b6"> 
   <h5>Listing&nbsp;2.1.&nbsp;Gradle <code class="code1">build.gradle.kts</code> for the samples in chapter 2</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">plugins {
  java
}

repositories {
  mavenCentral()
}

dependencies {
  implementation("io.vertx:vertx-core:3.8.0") <a class="pcalibre pcalibre1" id="CO1-1" shape="rect"></a><span class="pcalibre1">#1</span>
  implementation("ch.qos.logback:logback-classic:1.2.3")  <a class="pcalibre pcalibre1" id="CO1-2" shape="rect"></a><span class="pcalibre1">#2</span>
}

tasks.create&lt;JavaExec&gt;("run") { <a class="pcalibre pcalibre1" id="CO1-3" shape="rect"></a><span class="pcalibre1">#3</span>
  main = project.properties.getOrDefault("mainClass", "chapter2.hello.HelloVerticle") as String
  classpath = sourceSets["main"].runtimeClasspath
  systemProperties["vertx.logger-delegate-factory-class-name"] = "io.vertx.core.logging.SLF4JLogDelegateFactory" <a class="pcalibre pcalibre1" id="CO1-4" shape="rect"></a><span class="pcalibre1">#4</span>
}

java {
  sourceCompatibility = JavaVersion.VERSION_1_8
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhpcyBpcyB0aGUgVmVydC54IGNvcmUgbGlicmFyeSBkZXBlbmRlbmN5LgojMiBUaGUgbG9nYmFjay1jbGFzc2ljIGRlcGVuZGVuY3kgcHJvdmlkZXMgdGhlIFNMRjRKIGxvZ2dlciBBUEkgYW5kIHRoZSBsb2diYWNrIGltcGxlbWVudGF0aW9uLgojMyBUaGlzIHdpbGwgYWxsb3cgcnVubmluZyBzYW1wbGVzIHdpdGggR3JhZGxlIGZyb20gdGhlIGNvbW1hbmQgbGluZS4KIzQgVGhpcyBlbnN1cmVzIHRoYXQgVmVydC54IGl0c2VsZiBhbHNvIHVzZXMgU0xGNEogbG9nZ2luZy4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="14" id="14" data-hash="eef2878eaf5ca8aeec74ebf86b23c33f"> 
   <p>The Gradle build is a very simple one for a Java project. Since we will have several examples to run, we don’t rely on the Gradle application plugin but define our own custom run task where we can pass the name of the class to execute. We also take advantage of it to ensure that logging is properly configured and unified to SLF4J.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="15" id="15" data-hash="be41c2c5fce7575ed3a92bb490de2398"> 
   <h5>Listing&nbsp;2.2.&nbsp;Logback configuration to reduce Netty verbosity</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">&lt;configuration&gt;
  <a class="pcalibre pcalibre1" id="CO2-1" shape="rect"></a><span class="pcalibre1">#1</span>
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%level [%thread] %logger{0} - %msg%n&lt;/pattern&gt;  <a class="pcalibre pcalibre1" id="CO2-2" shape="rect"></a><span class="pcalibre1">#2</span>
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;logger name="io.netty" level="warn"/&gt;  <a class="pcalibre pcalibre1" id="CO2-3" shape="rect"></a><span class="pcalibre1">#3</span>

  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT"/&gt;
  &lt;/root&gt;
&lt;/configuration&gt;</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhpcyBkZWZpbmVzIGFuIGFwcGVuZGVyIHRvIHNlbmQgZXZlbnRzIHRvIHRoZSBjb25zb2xlLgojMiBUaGUgcGF0dGVybiBkZWZpbmVzIGhvdyB0aGUgbG9nIGV2ZW50cyBsb29rIGxpa2UuCiMzIFdlIGRyb3AgTmV0dHkgbG9nIGV2ZW50cyB0aGF0IGFyZSBtb3JlIHZlcmJvc2UgdGhhbiB3YXJuaW5ncy4="></div> 
   </div> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="16" id="16" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="17" id="17" data-hash="f44a11512df592aefa83b0d615206921"> 
     <p>Vert.x uses Netty and logging in Netty is quite verbose with the default Logback configuration. We can reduce the amount of log entries by creating a src/main/resources/logback.xml file and adding the configuration as in listing 2.2. To make the log samples shorter in this book we also removed event dates and shortened logger class names ($logger{0}). Please refer to the Logback documentation to understand how to configure it [LogbackDoc].</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="18" id="18" data-hash="0fdab1510f7bc27b1b64da54947246d7"> 
   <h3 class="calibre29" id="heading_id_5"><a class="pcalibre pcalibre1" id="the-verticle-class" shape="rect"></a>2.1.2 &nbsp;The verticle class</h3> 
  </div> 
  <div class="readable-text scrambled" refid="19" id="19" data-hash="8ef9c1beb298e62e89f9e16722dede6b"> 
   <p>The whole verticle and application fits in the Java class of listing 2.3.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="20" id="20" data-hash="1b3bed62cd299f3b7860c8863e314429"> 
   <h5>Listing&nbsp;2.3.&nbsp;A sample verticle</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">package chapter2.hello;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloVerticle extends AbstractVerticle {
  private final Logger logger = LoggerFactory.getLogger(HelloVerticle.class);
  private long counter = 1;

  @Override
  public void start() {
    vertx.setPeriodic(5000, id -&gt; {  #1
      logger.info("tick");
    });

    vertx.createHttpServer()
      .requestHandler(req -&gt; {  #2
        logger.info("Request #{} from {}", counter++, req.remoteAddress().host());
        req.response().end("Hello!");
      })
      .listen(8080);
    logger.info("Open http://localhost:8080/");
  }

  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();  #3
    vertx.deployVerticle(new HelloVerticle());  #4
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhpcyBkZWZpbmVzIGEgcGVyaW9kaWMgdGFzayBldmVyeSA1IHNlY29uZHMuCiMyIFRoZSBIVFRQIHNlcnZlciBjYWxscyB0aGlzIGhhbmRsZXIgb24gZXZlcnkgcmVxdWVzdC4KIzMgV2UgbmVlZCBhIGdsb2JhbCBWZXJ0LnggaW5zdGFuY2UuCiM0IFRoaXMgaXMgdGhlIHNpbXBsZXN0IHdheSB0byBkZXBsb3kgYSB2ZXJ0aWNsZS4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="21" id="21" data-hash="44c7eef1f4797e139eb8bc965f449c06"> 
   <p>This verticle defines 2 event handlers: one for periodic tasks every 5 seconds, and one for processing HTTP requests in a HTTP server. The main method instantiates a global Vert.x instance, and deploys an instance of the verticle.</p> 
  </div> 
  <div class="readable-text scrambled" refid="22" id="22" data-hash="b38b88359a6d36a8991d7b9539fa90bd"> 
   <p>Defining a verticle code in Java is typically done by specializing the AbstractVerticle class. There exists a Verticle interface that one could in theory implement, but AbstractVerticle provides all the event processing, configuration and execution plumbing that Vert.x users need.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="23" id="23" data-hash="f35a087d0dc71beb3a7204d91c1c49e4"> 
     <h5>Note</h5> 
    </div> 
    <div class="readable-text scrambled" refid="24" id="24" data-hash="beb505ca292c3d2c97060f3e11d6b2ef"> 
     <p>Since Vert.x is a library and not a framework, you can create a Vert.x instance from a main method, or from any other class and then deploy verticles.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="25" id="25" data-hash="bd6487358dd6044addc8b0c006083f5f"> 
   <p>The life-cycle of a verticle is simply made of start and stop events. The AbstractVerticle class provides start and stop methods that can be overridden. By default these methods do nothing.</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="26" id="26" data-hash="dea94b2fc01e58346c1f84e453c649a9"> Bkb <code class="code">start</code> edohmt ytylacilp tinnsoca puets npz sranledh iizniainottlia, fjov getints c coediipr care edhrnal znb itrangst s HRRL ervsre nj nigtsli <a class="pcalibre para2" href="/book/vertx-in-action/chapter-2/v-10/hello-verticle" shape="rect" title="Example 2.3. A sample verticle">2.3</a>.<br> </li> 
   <li class="listitem readable-text scrambled" refid="27" id="27" data-hash="e37d5d053f818d7b6a9814f28bdb2abf"> Cyx <code class="code">stop</code> tdohme cj nelemetipdm nowg khpuengeseio ksast tzk uqiderre, asdp zc slocgin vvhn bateaads esnconnctoi.<br> </li> 
  </ol> 
  <div class="readable-text" refid="28" id="28" data-hash="36b66b9228ba88dbb6451a2d9decf06a"> 
   <h3 class="calibre29" id="heading_id_6"><a class="pcalibre pcalibre1" id="running-and-first-observations" shape="rect"></a>2.1.3 &nbsp;Running and first observations</h3> 
  </div> 
  <div class="readable-text scrambled" refid="29" id="29" data-hash="4d81dc10091c4cb7c2e1331916610549"> 
   <p>The application can be launched as a regular Java application by running the main method either from an integrated development environment or from the command-line. To run on the command line using Gradle, you can use the following command:</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="30" id="30" data-hash="c8d8c7cbba8840ac56213ef18d3cf9d6"> 
   <div class="code-area-container"> 
    <pre class="code-area">$ ./gradlew run -PmainClass=chapter2.hello.HelloVerticle</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="31" id="31" data-hash="a6ee9d3e37f1940924ac78b256a29c78"> 
   <p>We again assume that you will run this from a Unix shell, be it under Linux, macOS or Windows through the Windows Subsystem for Linux. If you run the command from a traditional Windows terminal, there is a .bat file for Gradle so you will need to replace ./gradlew with gradlew.bat.</p> 
  </div> 
  <div class="readable-text scrambled" refid="32" id="32" data-hash="08df0be3c188f496a1d4101fd77b2245"> 
   <p>Once the application runs, we can perform a few HTTP requests at localhost:8080/ with a web browser, or by using command-line tools such as cUrl and HTTPie. The logs shall be similar to that of listing 2.4.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="33" id="33" data-hash="e1005e1fcec9d16363c9f0a50f33b277"> 
   <h5>Listing&nbsp;2.4.&nbsp;Sample log output when running <code class="code1">HelloVerticle</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">INFO [vert.x-eventloop-thread-0] HelloVerticle - Open http://localhost:8080/      #1
INFO [vert.x-eventloop-thread-0] HelloVerticle - tick                             #2
INFO [vert.x-eventloop-thread-0] HelloVerticle - Request #1 from 0:0:0:0:0:0:0:1  #3
INFO [vert.x-eventloop-thread-0] HelloVerticle - Request #2 from 0:0:0:0:0:0:0:1
INFO [vert.x-eventloop-thread-0] HelloVerticle - Request #3 from 0:0:0:0:0:0:0:1
INFO [vert.x-eventloop-thread-0] HelloVerticle - Request #4 from 0:0:0:0:0:0:0:1
INFO [vert.x-eventloop-thread-0] HelloVerticle - tick</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhlIEhUVFAgc2VydmVyIGlzIG5vdyByZWFkeS4KIzIgQSBwZXJpb2RpYyB0YXNrIGV2ZW50IGxvZy4KIzMgQSBIVFRQIHJlcXVlc3QgZXZlbnQgbG9nLg=="></div> 
   </div> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="34" id="34" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="35" id="35" data-hash="d0b0c8d1ed52bdb177c836b8f30d7b8c"> 
     <p>In some of the remaining samples we have shortened class definitions. We have especially removed package definitions, imports, and main methods that are similar to that of listing 2.3. When in doubt, please consult the full source code of the samples.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="36" id="36" data-hash="fcc9aa16cb1150a29104bf32fe11cc75"> 
   <p>The Logback configuration that we are using shows the name of the thread associated with an event. We can already check an important property of Vert.x verticles in log entries: event processing happens on a single event-loop thread. Both the periodic tasks and HTTP requests processing happen on a thread that appears as vert.x-eventloop-thread-0 in the logs.</p> 
  </div> 
  <div class="readable-text scrambled" refid="37" id="37" data-hash="74264f9517c1e10e31a9d7af471d2019"> 
   <p>An obvious benefit with this design is that a verticle instance is always executing event processing on the same thread, so there is no need for using thread synchronization primitives. In a multi-threaded design updating the counter field would require either a synchronized block or the usage of java.util.concurrent.AtomicLong. There is no such issue here so a plain long field can be safely used.</p> 
  </div> 
  <div class="readable-text scrambled" refid="38" id="38" data-hash="67897f8c376ff1c624c5fde9efabcd5b"> 
   <p>Preparation methods such as createHttpServer or setTimer may be called from a non-Vert.x thread. This may happen when directly using a Vertx object without a verticle, or when writing unit tests. This is however not a problem as usage of the Vertx class methods is thread-safe.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="39" id="39" data-hash="833bf1d22115689c17708c3e3e4c8753"> 
   <h5 id="hello-seq">Figure&nbsp;2.1.&nbsp;Execution of listing <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/hello-verticle" shape="rect" title="Example 2.3. A sample verticle">2.3</a></h5> 
   <img alt="hello" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/hello.png" width="875" loading="lazy" height="644" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="40" id="40" data-hash="a198a8be36942622dccc48a5f58e5b86"> 
   <p>Figure 2.1 shows the (simplified) interactions between the verticle, the handlers, Vert.x and the event sources. Each arrow represents a method call between the participants. For instance HelloVerticle creates a periodic task handler by calling setPeriodic on the Vertx object, which in turns creates a periodic task using a Vert.x-internal timer. In turn, the timer periodically calls back the timerHandler handler in HelloVerticle.</p> 
  </div> 
  <div class="readable-text scrambled" refid="41" id="41" data-hash="90bcb69783296e364c2dd1274a72c005"> 
   <p>Note that we represented the calls to requestHandler and listen as being to the Vertx object as a shortcut, while in reality they are on an object that implements the HttpServer interface. The actual class is internal to Vert.x, and since it doesn’t serve the diagram to add another participant we merged it into Vertx.</p> 
  </div> 
  <div class="readable-text" refid="42" id="42" data-hash="3a7bd14d0d11279cd4f47448afadc6c2"> 
   <h2 class="calibre17" id="heading_id_7"><a class="pcalibre pcalibre1" id="more-on-verticles" shape="rect"></a>2.2 &nbsp;More on verticles</h2> 
  </div> 
  <div class="readable-text scrambled" refid="43" id="43" data-hash="dbda590f2fc6717d8c06c652e40e0610"> 
   <p>There are more things to know on writing and deploying verticles:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="44" id="44" data-hash="9751e0ba7a84c20ac193ecb35f218747"> rwyc eshpanp npow xdr veetn-vfyv jz neibg dbeoklc,<br> </li> 
   <li class="listitem readable-text scrambled" refid="45" id="45" data-hash="06e43867067d969a739e99ad8ef4921a"> bvw vr efred ntiftociiona xl kjlf-lycec otmncpiloe nj peseencr lv onnysuahrosc inztiailaotiin vtew,<br> </li> 
   <li class="listitem readable-text scrambled" refid="46" id="46" data-hash="be9aa24f36d170054e408040ed39845b"> vwq xr dploye npz gn-peylod ievlctser,<br> </li> 
   <li class="listitem readable-text scrambled" refid="47" id="47" data-hash="2462075a953cf95a44a8d03756d5cb76"> kuw rx ccsy grannfuctioio srqs.<br> </li> 
  </ol> 
  <div class="readable-text" refid="48" id="48" data-hash="94ee6dbc31d40495b21c079c09719a61"> 
   <p>We cover each topic using very simple yet focused examples.</p> 
  </div> 
  <div class="readable-text" refid="49" id="49" data-hash="4e07bc72528adacb18542c63bcd25d15"> 
   <h3 class="calibre29" id="heading_id_8"><a class="pcalibre pcalibre1" id="blocking-and-the-event-loop" shape="rect"></a>2.2.1 &nbsp;Blocking and the event-loop</h3> 
  </div> 
  <div class="readable-text scrambled" refid="50" id="50" data-hash="09adb20da8465dd32efc773861cd0f05"> 
   <p>Handler callbacks are run from event-loop threads. It is important that code running on an event-loop spends as little time as possible, so that the event-loop thread can have a higher throughput in the number of processed events. This is why no long-running or blocking I/O operations shall happen on the event-loop.</p> 
  </div> 
  <div class="readable-text scrambled" refid="51" id="51" data-hash="90247ab0a15359215006415e793afdfc"> 
   <p>That being said it may not always be easy to spot blocking code, especially when using third-party libraries. Vert.x provides a checker that detects when an event-loop is being blocked for too long.</p> 
  </div> 
  <div class="readable-text scrambled" refid="52" id="52" data-hash="7ac3872959b071c48219c9c98b27c0fa"> 
   <p>To illustrate that, let us see what happens when we introduce an infinite loop in an event handler callback.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="53" id="53" data-hash="dbfa9963c5030c64b5a40b7df6115b9f"> 
   <h5>Listing&nbsp;2.5.&nbsp;Sample where the event-loop is being blocked</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class BlockEventLoop extends AbstractVerticle {

  @Override
  public void start() {
    vertx.setTimer(1000, id -&gt; {
      while (true);  #1
    });
  }

  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new BlockEventLoop());
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgSW5maW5pdGUgbG9vcCE="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="54" id="54" data-hash="55ba6fbc6ed9fb24ae9630a071af8c5b"> 
   <p>The code in listing 2.5 defines a 1 second timer, and the handler callback enters into an infinite loop.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="55" id="55" data-hash="621a7d2bc38d986e0c024873e618202d"> 
   <h5>Listing&nbsp;2.6.&nbsp;Sample log output when running listing <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/blocker" shape="rect" title="Example 2.5. Sample where the event-loop is being blocked">2.5</a></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">WARN [vertx-blocked-thread-checker] BlockedThreadChecker - Thread Thread[vert.x-eventloop-thread-0,5,main] 
      has been blocked for 2871 ms, time limit is 2000
WARN [vertx-blocked-thread-checker] BlockedThreadChecker - Thread Thread[vert.x-eventloop-thread-0,5,main] 
      has been blocked for 3871 ms, time limit is 2000  #1
(...)
WARN [vertx-blocked-thread-checker] BlockedThreadChecker - Thread Thread[vert.x-eventloop-thread-0,5,main] 
      has been blocked for 5879 ms, time limit is 2000
io.vertx.core.VertxException: Thread blocked
  at chapter2.blocker.BlockEventLoop.lambda$start$0(BlockEventLoop.java:11)
  at chapter2.blocker.BlockEventLoop$$Lambda$10/152379791.handle(Unknown Source)
(...)</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhlIHRocmVhZCBjaGVja2VyIGlzIG5vdCBoYXBweS4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="56" id="56" data-hash="c10e637377f639687d06e2c78dcbcd1b"> 
   <p>Listing 2.6 provides a typical log output when running the code from listing 2.5. As we can see, warnings start to appear as the event-loop thread is still running the infinite loop, and hence is not available for processing other events. After some iterations (5 seconds by default) the warning is being enriched with stack trace dumps, so we can clearly identify the culprit in our code. Note that this is only a warning, the event-loop thread checker cannot kill the handler that is taking too long to complete its task.</p> 
  </div> 
  <div class="readable-text scrambled" refid="57" id="57" data-hash="9a6d62e122dbf66cb8f36f0d481b93b4"> 
   <p>Of course it will happen that you need to defer to blocking or long-running code, and this is the subject of a section later in this chapter.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="58" id="58" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="59" id="59" data-hash="f305ae73b69110a39e36b0c1ff891c91"> 
     <p>The time limit is by default of 2 seconds, but it can be configured to a different value. There are environments such as embedded devices where processing power is slower, and it is normal to increase the thread checker threshold.</p> 
    </div> 
    <div class="readable-text" refid="60" id="60" data-hash="f6ab3a9136759893236ade8cc7fb2622"> 
     <p>You can use system properties to change the settings:</p> 
    </div> 
    <div class="readable-text scrambled" refid="61" id="61" data-hash="cb229a432dac27efcdc5f20daf23951d"> 
     <p>Note that this configuration is global and cannot be fine-tuned on a per-verticle basis.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="62" id="62" data-hash="b695982ebe81f711c71a2e92fd3d7714"> 
   <h3 class="calibre29" id="heading_id_9"><a class="pcalibre pcalibre1" id="asynchronous-notification-of-life-cycle-events" shape="rect"></a>2.2.2 &nbsp;Asynchronous notification of life-cycle events</h3> 
  </div> 
  <div class="readable-text scrambled" refid="63" id="63" data-hash="32baf330258e2c6eebc31fe70e7900ec"> 
   <p>So far we have seen examples with start() life-cycle methods. The contract in these methods is that a verticle has successfully completed its start life-cycle event processing unless the method throws an exception. The same applies for stop() methods.</p> 
  </div> 
  <div class="readable-text scrambled" refid="64" id="64" data-hash="ffe9eb65a395bb8af4096b3a6b02fbf5"> 
   <p>There is however a problem: some of the operations in a start or a stop method may be asynchronous, hence they may complete after a call to start() or stop() has returned.</p> 
  </div> 
  <div class="readable-text scrambled" refid="65" id="65" data-hash="dca07e048987c6fe3dd27fb789e9b1b2"> 
   <p>Let us see how to properly notify of deferred success, or failure. A good example is starting a HTTP server, which is a non-blocking operation.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="66" id="66" data-hash="4c1da115be6b7ebce30b228299ed28c3"> 
   <h5>Listing&nbsp;2.7.&nbsp;Example of an asynchronous start life-cycle method</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class SomeVerticle extends AbstractVerticle {

   @Override
  public void start(Promise&lt;Void&gt; promise) {   <a class="pcalibre pcalibre1" id="CO7-1" shape="rect"></a><span class="pcalibre1">#1</span>
    vertx.createHttpServer()
      .requestHandler(req -&gt; req.response().end("Ok"))
      .listen(8080, ar -&gt; {
        if (ar.succeeded()) {       <a class="pcalibre pcalibre1" id="CO7-2" shape="rect"></a><span class="pcalibre1">#2</span>
          promise.complete();   <a class="pcalibre pcalibre1" id="CO7-3" shape="rect"></a><span class="pcalibre1">#3</span>
        } else {
          promise.fail(ar.cause()); <a class="pcalibre pcalibre1" id="CO7-4" shape="rect"></a><span class="pcalibre1">#4</span>
        }
      });
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhlIHByb21pc2UgaXMgb2YgdHlwZSB2b2lkIGJlY2F1c2UgVmVydC54IGlzIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgZGVwbG95bWVudCBjb21wbGV0aW9uIGFuZCB0aGVyZSBpcyBubyB2YWx1ZSB0byBjYXJyeSBhbG9uZy4KIzIgVGhlIGxpc3RlbiB2YXJpYW50IHRoYXQgc3VwcG9ydHMgYW4gYXN5bmNocm9ub3VzIHJlc3VsdCBhbGxvd3Mga25vd2luZyBpZiB0aGUgb3BlcmF0aW9uIGZhaWxlZCBvciBub3QuCiMzIGNvbXBsZXRlKCkgaXMgdXNlZCB0byBtYXJrIHRoZSBQcm9taXNlIGFzIGNvbXBsZXRlZCAod2hlbiB0aGUgUHJvbWlzZSBpcyBub3Qgb2YgdHlwZSB2b2lkIGEgdmFsdWUgY2FuIGJlIHBhc3NlZCkuCiM0IElmIHRoZSBsaXN0ZW4gb3BlcmF0aW9uIGZhaWxzLCB0aGVuIHdlIG1hcmsgdGhlIFByb21pc2UgYXMgZmFpbGVkIGFuZCBwcm9wYWdhdGUgdGhlIGVycm9yLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="67" id="67" data-hash="32859e31a4159f5310b6c0b9cb841113"> 
   <p>Listing 2.7 provides an example where the verticle reports an asynchronous notification when it starts. It is important because starting a HTTP server can fail. Indeed, the TCP port may be used by another process, in which case the HTTP server cannot start, and hence the verticle has not successfully deployed. To do that, we use a variant of the listen method with callback called when the operation completes.</p> 
  </div> 
  <div class="readable-text scrambled" refid="68" id="68" data-hash="e99f1424186f3afc1497ba67b1877468"> 
   <p>The start and stop methods in AbstractVerticle support variants with an argument of type io.vertx.core.Promise. As the name suggest, a Vert.x Promise is an adaptation of the future and promises model for processing asynchronous results [Liskov88]. A promise is used to write an asynchronous result, while a future is used to view an asynchronous result. Given a Promise object, you can call the future() method to obtain a future or type io.vertx.core.Future.</p> 
  </div> 
  <div class="readable-text scrambled" refid="69" id="69" data-hash="83b149fc0501f0be0c3c7756bc9b4d7c"> 
   <p>In listing 2.7 the Promise object is set to be completed when the verticle has successfully completed its start or stop life-cycle. If an error arises, then the Promise object is failed with an exception describing the error, and the verticle deployment is failed.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="70" id="70" data-hash="b80239309ed310830e48af1d245f4120"> 
   <h5 id="async-without-future">Figure&nbsp;2.2.&nbsp;Sequence diagram when starting a HTTP server without a promise and a <code class="code1">listen</code> handler</h5> 
   <img alt="async without future" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/async-without-future.png" width="774" loading="lazy" height="512" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="browsable-container figure-container" refid="71" id="71" data-hash="e29793f5fa5fde1d6bd020b6ad876297"> 
   <h5 id="async-with-future">Figure&nbsp;2.3.&nbsp;Sequence diagram when starting a HTTP server with a promise and a <code class="code1">listen</code> handler</h5> 
   <img alt="async with future" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/async-with-future.png" width="864" loading="lazy" height="600" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="72" id="72" data-hash="bdd50fb4d3dc4d43f7ef864bd7f8968d"> 
   <p>To better understand what happens here, figure 2.3 illustrates the interactions between the verticle, the Vert.x object, and the internal Vert.x deployer object responsible for calling the start method. We can check that the deployer waits for the promise completion to know if the deployment was a success or not, even after the call to method start has returned. By contrast figure 2.2 shows the interactions when not using the variant of start that accepts a Promise object, and there is no way the deployer is being notified of an error.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="73" id="73" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="74" id="74" data-hash="2c044cc75dec3e155f5580bd2be05adf"> 
     <p>It is a good robustness practice to use the asynchronous method variants that accept a callback to notify of errors, just like the listen method in listing 2.7. We will not always do this in the remainder of this book when it allows us to reduce the verbosity of code samples.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="75" id="75" data-hash="07c46159753a44362c64fc335796daef"> 
   <h3 class="calibre29" id="heading_id_10"><a class="pcalibre pcalibre1" id="deploying-verticles" shape="rect"></a>2.2.3 &nbsp;Deploying verticles</h3> 
  </div> 
  <div class="readable-text scrambled" refid="76" id="76" data-hash="53ca483026c721e36b49530203abb8f0"> 
   <p>So far we have been deploying verticles from a main method embedded in a single verticle class.</p> 
  </div> 
  <div class="readable-text scrambled" refid="77" id="77" data-hash="11cbd27dd7e77f08903b23a76aeb5dd9"> 
   <p>Verticles are always deployed (and un-deployed) through the Vertx object. You may do so from any method, but the typical way to deploy an application made of verticles is to:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="78" id="78" data-hash="8da566584c2b1f26f4c7110733e3ede1"> podeyl s <em class="calibre9">mjzn</em> reeivclt, pnz<br> </li> 
   <li class="listitem readable-text scrambled" refid="79" id="79" data-hash="3baad69720852b04c7fc952e08596f49"> rbx <em class="calibre9">cnjm</em> reetclvi elypdso thore ircveetls, uzn<br> </li> 
   <li class="listitem readable-text scrambled" refid="80" id="80" data-hash="07f9989dbeed9f65a836bbf8662fd201"> xur pydoleed elietsvrc msu nj ynrt polyed htfurer eclrsivte.<br> </li> 
  </ol> 
  <div class="readable-text scrambled" refid="81" id="81" data-hash="b686985641c3d4cc318cbc160f4f1f32"> 
   <p>Note that while this sounds hierarchical, Vert.x has no formal notion of parent / child verticles.</p> 
  </div> 
  <div class="readable-text" refid="82" id="82" data-hash="77ad74d6cc26d3431342637ede746bce"> 
   <p>To illustrate that, let us define some verticles.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="83" id="83" data-hash="e00415823d9acec599622442d1203416"> 
   <h5>Listing&nbsp;2.8.&nbsp;A sample verticle to deploy</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class EmptyVerticle extends AbstractVerticle {
  private final Logger logger = LoggerFactory.getLogger(EmptyVerticle.class);

  @Override
  public void start() {
    logger.info("Start");   #1
  }

  @Override
  public void stop() {
    logger.info("Stop");
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2UganVzdCBsb2cu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="84" id="84" data-hash="13c909e6a973e2335598ccb2dfd93f4c"> 
   <p>Listing 2.8 defines a simple verticle. It does not do anything interesting albeit logging when it starts and stops.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="85" id="85" data-hash="670500ed4b45519a6984fb90f1f0a6e9"> 
   <h5>Listing&nbsp;2.9.&nbsp;A verticle that deploys and un-deploys other verticles.</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class Deployer extends AbstractVerticle {
  private final Logger logger = LoggerFactory.getLogger(Deployer.class);

  @Override
  public void start() {
    long delay = 1000;
    for (int i = 0; i &lt; 50; i++) {
      vertx.setTimer(delay, id -&gt; deploy());              <a class="pcalibre pcalibre1" id="CO9-1" shape="rect"></a><span class="pcalibre1">#1</span>
      delay = delay + 1000;
    }
  }

  private void deploy() {
    vertx.deployVerticle(new EmptyVerticle(), ar -&gt; {     <a class="pcalibre pcalibre1" id="CO9-2" shape="rect"></a><span class="pcalibre1">#2</span>
      if (ar.succeeded()) {
        String id = ar.result();
        logger.info("Successfully deployed {}", id);
        vertx.setTimer(5000, tid -&gt; undeployLater(id));   <a class="pcalibre pcalibre1" id="CO9-3" shape="rect"></a><span class="pcalibre1">#3</span>
      } else {
        logger.error("Error while deploying", ar.cause());
      }
    });
  }

  private void undeployLater(String id) {
    vertx.undeploy(id, ar -&gt; {                            <a class="pcalibre pcalibre1" id="CO9-4" shape="rect"></a><span class="pcalibre1">#4</span>
      if (ar.succeeded()) {
        logger.info("{} was undeployed", id);
      } else {
        logger.error("{} could not be undeployed", id);
      }
    });
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2UgZGVwbG95IGV2ZXJ5IHNlY29uZC4KIzIgRGVwbG95aW5nIGEgdmVydGljbGUgaXMgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbiwgYW5kIHRoZXJlIGlzIGEgdmFyaWFudCBvZiB0aGUgZGVwbG95IG1ldGhvZCB0aGF0IHN1cHBvcnRzIGFuIGFzeW5jaHJvbm91cyByZXN1bHQuCiMzIFdlIHdpbGwgdW4tZGVwbG95IGEgdmVydGljbGUgYWZ0ZXIgNSBzZWNvbmRzLgojNCBVbi1kZXBsb3lpbmcgaXMgdmVyeSBzaW1pbGFyIHRvIGRlcGxveWluZy4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="86" id="86" data-hash="f1a79261c14d2377c78340788284dcf5"> 
   <p>Listing 2.9 defines a verticle that deploys 50 instances of the EmptyVerticle class from 2.8. The usage of a timer allows separating each deployment by 1 second. The deploy method uses another timer for un-deploying a verticle 5 seconds after it has been deployed. Deployment assigns a unique identifier string to a verticle, which can later be reused for un-deploying.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="87" id="87" data-hash="3f013bc44dd65bc62cffa5d28d20132a"> 
   <h5>Listing&nbsp;2.10.&nbsp;Main class to deploy the <code class="code1">Deployer</code> verticle</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public static void main(String[] args) {
  Vertx vertx = Vertx.vertx();
  vertx.deployVerticle(new Deployer());
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="88" id="88" data-hash="fb63819da62e8da94271317c22543d30"> 
   <p>Last but not least, the Deployer verticle itself can be deployed from a main method and class given in listing 2.10.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="89" id="89" data-hash="a54cc4e6880fa268b726538208a36cd5"> 
   <h5>Listing&nbsp;2.11.&nbsp;Logs excerpts of running the code in listing <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/deploy-main" shape="rect" title="Example 2.10. Main class to deploy the Deployer verticle">2.10</a></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">INFO [vert.x-eventloop-thread-1] EmptyVerticle - Start
INFO [vert.x-eventloop-thread-0] Deployer - Successfully deployed 05553394-b6ce-4f47-9076-2c6648d65329  #1
INFO [vert.x-eventloop-thread-2] EmptyVerticle - Start
INFO [vert.x-eventloop-thread-0] Deployer - Successfully deployed 6d920f33-f317-4964-992f-e712185fe514
(...)
INFO [vert.x-eventloop-thread-0] Deployer - 8153abb7-fc64-496e-8155-75c27a93b56d was undeployed   #2
INFO [vert.x-eventloop-thread-13] EmptyVerticle - Start
INFO [vert.x-eventloop-thread-0] Deployer - Successfully deployed 0f69ccd8-1344-4b70-8245-020a4815cc96
(...)</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgQSB2ZXJ0aWNsZSBoYXMgYmVlbiBkZXBsb3llZC4KIzIgQSB2ZXJ0aWNsZSBoYXMgYmVlbiB1bi1kZXBsb3llZC4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="90" id="90" data-hash="a760ea8bacf416a32828557ea34dddc7"> 
   <p>Running this example yield log entries as found in listing 2.11. We can see the log entries from the vert.x-eventloop-thread-0 thread: they correspond to the Deployer verticle. We can then see life-cycle log events from EmptyVerticle instances, and they use other event-loop threads.</p> 
  </div> 
  <div class="readable-text scrambled" refid="91" id="91" data-hash="2ac80117236cf8df25596c18549959b4"> 
   <p>Interestingly, we are deploying 50 verticles from Deployer, yet there are likely less threads than verticles that appear in logs. By default Vert.x creates twice the number of event-loop threads than CPU cores. If you have 8 cores then a Vert.x application has 16 event-loops. The assignment of verticles to event-loops is done in a round-robin fashion.</p> 
  </div> 
  <div class="readable-text scrambled" refid="92" id="92" data-hash="09725942425c2853e1e9dc579f36949d"> 
   <p>This teaches us an interesting lesson: while a verticle always uses the same event-loop thread, the event-loop threads are being shared by multiple verticles. This design results in a predictable number of threads for running an application.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="93" id="93" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="94" id="94" data-hash="18ae14ecf5ff85d80d44b603103da328"> 
     <p>It is possible to tweak how many event-loops should be available. It is not possible to manually allocate a given verticle to an event-loop. This should never be a problem in practice, but in the worst case you can always plan the verticles deployment order.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="95" id="95" data-hash="e98c890131a8d97938c9557ea985f3ea"> 
   <h3 class="calibre29" id="heading_id_11"><a class="pcalibre pcalibre1" id="passing-configuration-data" shape="rect"></a>2.2.4 &nbsp;Passing configuration data</h3> 
  </div> 
  <div class="readable-text scrambled" refid="96" id="96" data-hash="6d4b499e06da867bab5bbbfc8ce786a2"> 
   <p>Application code often needs configuration data. A good example is that of code that connects to a database server: it typically needs a host name, a TCP port, a login and a password. Since the values change from one deployment configuration to the other, such configuration needs to be accessed from a configuration API.</p> 
  </div> 
  <div class="readable-text scrambled" refid="97" id="97" data-hash="abd46f0721112e31c275c8120c34d02c"> 
   <p>Vert.x verticles can be passed such configuration data when they are deployed. We will see later in this book that some more advanced forms of configuration can be used, but the Vert.x core API already provides a generic API that is very useful.</p> 
  </div> 
  <div class="readable-text scrambled" refid="98" id="98" data-hash="3850384e9b02b5c22c856f6467267e72"> 
   <p>Configuration needs to be passed as JSON data, using the Vert.x JSON API materialized by the JsonObject and JsonArray classes in the io.vertx.core package.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="99" id="99" data-hash="98cb6a2d21f5b79dcbb1363d8d19c623"> 
   <h5>Listing&nbsp;2.12.&nbsp;Passing configuration data to a verticle</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class SampleVerticle extends AbstractVerticle {
  private final Logger logger = LoggerFactory.getLogger(SampleVerticle.class);

  @Override
  public void start() {
    logger.info("n = {}", config().getInteger("n", -1)); <a class="pcalibre pcalibre1" id="CO11-1" shape="rect"></a><span class="pcalibre1">#1</span>
  }

  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    for (int n = 0; n &lt; 4; n++) {
      JsonObject conf = new JsonObject().put("n", n);   <a class="pcalibre pcalibre1" id="CO11-2" shape="rect"></a><span class="pcalibre1">#2</span>
      DeploymentOptions opts = new DeploymentOptions()
        .setConfig(conf)    <a class="pcalibre pcalibre1" id="CO11-3" shape="rect"></a><span class="pcalibre1">#3</span>
        .setInstances(n);   <a class="pcalibre pcalibre1" id="CO11-4" shape="rect"></a><span class="pcalibre1">#4</span>
      vertx.deployVerticle("chapter2.opts.SampleVerticle", opts);  <a class="pcalibre pcalibre1" id="CO11-5" shape="rect"></a><span class="pcalibre1">#5</span>
    }
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgY29uZmlnKCkgcmV0dXJucyB0aGUgSnNvbk9iamVjdCBjb25maWd1cmF0aW9uIGluc3RhbmNlLCBhbmQgdGhlIGFjY2Vzc29yIG1ldGhvZCBzdXBwb3J0IG9wdGlvbmFsIGRlZmF1bHQgdmFsdWVzLiBIZXJlIGlmIHRoZXJlIGlzIG5vIG4ga2V5IGluIHRoZSBKU09OIG9iamVjdCwgdGhlbiAtMSBpcyBiZWluZyByZXR1cm5lZC4KIzIgV2UgY3JlYXRlIGEgSlNPTiBvYmplY3QgYW5kIHB1dCBhbiBpbnRlZ2VyIHZhbHVlIGZvciBrZXkgbi4KIzMgVGhlIERlcGxveW1lbnRPcHRpb24gYWxsb3dzIG1vcmUgY29udHJvbCBvbiBhIHZlcnRpY2xlLCBpbmNsdWRpbmcgcGFzc2luZyBjb25maWd1cmF0aW9uIGRhdGEuCiM0IFdlIGNhbiBkZXBsb3kgbXVsdGlwbGUgaW5zdGFuY2VzIGF0IG9uY2UuCiM1IFNpbmNlIHdlIGRlcGxveSBtdWx0aXBsZSBpbnN0YW5jZXMsIHdlIG5lZWQgdG8gcG9pbnQgdG8gdGhlIHZlcnRpY2xlIHVzaW5nIGl0cyBmdWxseSBxdWFsaWZpZWQgY2xhc3MgbmFtZSAoRlFDTikgcmF0aGVyIHRoYW4gdXNpbmcgdGhlIG5ldyBvcGVyYXRvci4gRm9yIGRlcGxveWluZyBqdXN0IDEgaW5zdGFuY2UsIHlvdSBtYXkgZWxlY3QgZWl0aGVyIGFuIGluc3RhbmNlIGNyZWF0ZWQgd2l0aCBuZXcgb3IgdXNpbmcgYSBGUUNOLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="100" id="100" data-hash="dffd28fc376b2e4ff7caaa2433baea8b"> 
   <p>Listing 2.12 gives an example of deploying many verticles and passing configuration data.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="101" id="101" data-hash="63dadf60925a85f87834600d95e39d7b"> 
   <h5>Listing&nbsp;2.13.&nbsp;Sample execution output when running the code in listing <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/config" shape="rect" title="Example 2.12. Passing configuration data to a verticle">2.12</a></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">INFO [vert.x-eventloop-thread-2] SampleVerticle - n = 2
INFO [vert.x-eventloop-thread-5] SampleVerticle - n = 3
INFO [vert.x-eventloop-thread-4] SampleVerticle - n = 3
INFO [vert.x-eventloop-thread-1] SampleVerticle - n = 2
INFO [vert.x-eventloop-thread-3] SampleVerticle - n = 3
INFO [vert.x-eventloop-thread-0] SampleVerticle - n = 1</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="102" id="102" data-hash="282e53ef45444a88e9e2809187c513a2"> 
   <p>Running the example gives the output of listing 2.13 and we can check the different values of configuration data.</p> 
  </div> 
  <div class="readable-text" refid="103" id="103" data-hash="55b75c3a402efe4d136998902865360d"> 
   <h2 class="calibre17" id="heading_id_12"><a class="pcalibre pcalibre1" id="when-code-needs-to-block" shape="rect"></a>2.3 &nbsp;When code needs to block</h2> 
  </div> 
  <div class="readable-text scrambled" refid="104" id="104" data-hash="7258650eb7b3bc45c0944516ae5d3e32"> 
   <p>The basic rule when running code on an event-loop is that it should not block, and it should run "fast enough". We have seen earlier that by default Vert.x detects and warns when an event-loop is being blocked for too long.</p> 
  </div> 
  <div class="readable-text scrambled" refid="105" id="105" data-hash="471cfbfe943cb324731a5b6536a53c09"> 
   <p>There are inevitably cases where you will have a hard time avoiding blocking code. It may happen because you are using a third-party library with another threading model, such as drivers for some networked services. Vert.x provides 2 options for dealing with such cases: worker verticles and the executeBlocking operation.</p> 
  </div> 
  <div class="readable-text" refid="106" id="106" data-hash="7fc8a6a2d054e778509174cf0096ee63"> 
   <h3 class="calibre29" id="heading_id_13"><a class="pcalibre pcalibre1" id="worker-verticles" shape="rect"></a>2.3.1 &nbsp;Worker verticles</h3> 
  </div> 
  <div class="readable-text scrambled" refid="107" id="107" data-hash="bb3fab76ad8b966b10500388097cd746"> 
   <p>Worker verticles are a special form of verticles that do not execute on an event-loop. Instead, they execute on worker threads, that is, threads taken from special worker pools. You may define your own worker thread pools and deploy worker verticles to them, but in most cases you will be just fine with using the default Vert.x worker pool.</p> 
  </div> 
  <div class="readable-text scrambled" refid="108" id="108" data-hash="620708d9afa88938f23a8039040542a0"> 
   <p>A worker verticle processes events just like an event-loop verticle would do, except that it can take an arbitrary long amount of time to do so. It is important to understand that:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="109" id="109" data-hash="e3dce477b49280d08d75ed2d1c8384bb"> z rekrwo tivclere jz rnx xqjr rx s isgnle orkwer dehart, zk lkiune cn tvene-bxfk lrveetci vecsisuesc vtnees mcu rkn eetxcue vn rkb mzvc hertad, sbn<br> </li> 
   <li class="listitem readable-text scrambled" refid="110" id="110" data-hash="13e0a23c704779115bb3043bd1ea8199"> ekorrw stevrecil zmq kfqn oh csdeesac py s nglsei eokrwr thared rs c ingev mjvr.<br> </li> 
  </ol> 
  <div class="readable-text scrambled" refid="111" id="111" data-hash="e7932785eb8bf84a0fbd752bcf7f1f67"> 
   <p>To put it simply: like event-loop verticles, worker verticles are single-threaded, but unlike event-loop verticles, the thread may not always be the same.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="112" id="112" data-hash="d8dcd9ec6f80e87d8d2d053f5626687c"> 
   <h5>Listing&nbsp;2.14.&nbsp;Sample worker verticle</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class WorkerVerticle extends AbstractVerticle {
  private final Logger logger = LoggerFactory.getLogger(WorkerVerticle.class);

  @Override
  public void start() {
    vertx.setPeriodic(10_000, id -&gt; {
      try {
        logger.info("Zzz...");
        Thread.sleep(8000);    #1
        logger.info("Up!");
      } catch (InterruptedException e) {
        logger.error("Woops", e);
      }
    });
  }

  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    DeploymentOptions opts = new DeploymentOptions()
      .setInstances(2)
      .setWorker(true);     #2
    vertx.deployVerticle("chapter2.worker.WorkerVerticle", opts);
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2UgY2FuIGJsb2NrIGFuZCBnZXQgbm8gd2FybmluZyEKIzIgTWFraW5nIGEgd29ya2VyIHZlcnRpY2xlIGlzIGEgZGVwbG95bWVudCBvcHRpb25zIGZsYWcu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="113" id="113" data-hash="fbfa9aad1139d6a3203b56229b89d50c"> 
   <p>Listing 2.14 gives an example where a worker verticle is being deployed with 2 instances. Every 10s, the code blocks for 8 seconds. Running this sample gives an output similar to that of listing 2.15. As we can see, different worker threads are being used for successive events.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="114" id="114" data-hash="02a6fd8fcf8c2482eebc084f92befb41"> 
   <h5>Listing&nbsp;2.15.&nbsp;Sample output of running listing <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/worker" shape="rect" title="Example 2.14. Sample worker verticle">2.14</a></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">INFO [vert.x-worker-thread-2] WorkerVerticle - Zzz...
INFO [vert.x-worker-thread-3] WorkerVerticle - Zzz...
INFO [vert.x-worker-thread-3] WorkerVerticle - Up!
INFO [vert.x-worker-thread-2] WorkerVerticle - Up!
INFO [vert.x-worker-thread-5] WorkerVerticle - Zzz...
INFO [vert.x-worker-thread-4] WorkerVerticle - Zzz...
INFO [vert.x-worker-thread-4] WorkerVerticle - Up!
INFO [vert.x-worker-thread-5] WorkerVerticle - Up!
(...)</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="115" id="115" data-hash="bf26d85e1aec3d63e66619eaa6943458"> 
     <h5>Warning</h5> 
    </div> 
    <div class="readable-text scrambled" refid="116" id="116" data-hash="fed56e191c9e90286b9f4af27f1ef2cf"> 
     <p>While deploying a verticle, there is an option for enabling multi-threading for worker verticles, in which case multiple events can be processed concurrently by a verticle, breaking the single-threaded processing assumption. This was always considered fairly advanced usage, and many users ended-up using it the wrong way and catching concurrency bugs. The feature is now under-cover and may even disappear in future Vert.x releases. Users are encouraged to simply adjust worker pool sizes to match the workload rather than enabling worker multi-threading.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="117" id="117" data-hash="781fe169dbc2d7ca8ff521884671c2dc"> 
   <h3 class="calibre29" id="heading_id_14"><a class="pcalibre pcalibre1" id="the-executeblocking-operation" shape="rect"></a>2.3.2 &nbsp;The <code class="code1">executeBlocking</code> operation</h3> 
  </div> 
  <div class="readable-text scrambled" refid="118" id="118" data-hash="53e8fa49db4e90eaefc3ca33c8161d98"> 
   <p>Worker verticles are a sensible option for running blocking tasks, but it may not always make sense to extract blocking code into worker verticles. This can lead to an explosion in the number of worker verticle classes for performing small duties, while each class may not form a sensible standalone functional unit.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="119" id="119" data-hash="b40c964f65d1117c4cbfd208b03820b4"> 
   <h5 id="mm-executeblocking">Figure&nbsp;2.4.&nbsp;Interactions in an <code class="code1">executeBlocking</code> call</h5> 
   <img alt="chapter2 executeblocking" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/chapter2-executeblocking.png" width="1234" loading="lazy" height="362" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="120" id="120" data-hash="1a8ce69e787f6bafc532c5860119aa9e"> 
   <p>The other option for running blocking code is to use the executeBlocking method from the Vertx class. This method takes some blocking code to execute, offloads it to a worker thread, then puts the result back to the event-loop as a new event, as illustrated in figure 2.4.</p> 
  </div> 
  <div class="readable-text" refid="121" id="121" data-hash="6061f1eb112e9a03d99f858819069e4b"> 
   <p>Listing <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/executeblocking" shape="rect" title="Example 2.16. Using executeBlocking">2.16</a> provides a sample usage.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="122" id="122" data-hash="db62d25a655a4629788de233d2a48e96"> 
   <h5>Listing&nbsp;2.16.&nbsp;Using <code class="code1">executeBlocking</code></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class Offload extends AbstractVerticle {
  private final Logger logger = LoggerFactory.getLogger(Offload.class);

  @Override
  public void start() {
    vertx.setPeriodic(5000, id -&gt; {
      logger.info("Tick");
      vertx.executeBlocking(this::blockingCode, this::resultHandler);  <a class="pcalibre pcalibre1" id="CO13-1" shape="rect"></a><span class="pcalibre1">#1</span>
    });
  }

  private void blockingCode(Promise&lt;String&gt; promise) {  <a class="pcalibre pcalibre1" id="CO13-2" shape="rect"></a><span class="pcalibre1">#2</span>
    logger.info("Blocking code running");
    try {
      Thread.sleep(4000);
      logger.info("Done!");
      promise.complete("Ok!");  <a class="pcalibre pcalibre1" id="CO13-3" shape="rect"></a><span class="pcalibre1">#3</span>
    } catch (InterruptedException e) {
      promise.fail(e);
    }
  }

  private void resultHandler(AsyncResult&lt;String&gt; ar) {  <a class="pcalibre pcalibre1" id="CO13-4" shape="rect"></a><span class="pcalibre1">#4</span>
    if (ar.succeeded()) {
      logger.info("Blocking code result: {}", ar.result());
    } else {
      logger.error("Woops", ar.cause());
    }
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgZXhlY3V0ZUJsb2NraW5nIHRha2VzIDIgcGFyYW1ldGVyczogdGhlIGNvZGUgdG8gcnVuIGFuZCBhIGNhbGxiYWNrIHdoZW4gaXQgaGFzIHJ1bi4KIzIgVGhlIGJsb2NraW5nIGNvZGUgdGFrZXMgYSBQcm9taXNlIG9iamVjdCBvZiBhbnkgdHlwZS4gSXQgaXMgYmVpbmcgdXNlZCB0byBldmVudHVhbGx5IHBhc3MgdGhlIHJlc3VsdC4KIzMgVGhlIHByb21pc2Ugb2JqZWN0IG5lZWRzIHRvIGVpdGhlciBjb21wbGV0ZSBvciBmYWlsLCBtYXJraW5nIHRoZSBlbmQgb2YgdGhlIGJsb2NraW5nIGNvZGUgZXhlY3V0aW9uLgojNCBQcm9jZXNzaW5nIHRoZSByZXN1bHQgb24gdGhlIGV2ZW50LWxvb3AgaXMganVzdCBhbm90aGVyIGFzeW5jaHJvbm91cyByZXN1bHQu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="123" id="123" data-hash="d7226fab9d93b1bf0e53b193f72fe406"> 
   <p>Listing 2.17 provides a sample output when running the code in listing 2.16. As we can see, the execution is offloaded to worker threads, but the result processing still happens on the event-loop.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="124" id="124" data-hash="0c9389e1d6b57b0af07f7ff830df8ebc"> 
   <h5>Listing&nbsp;2.17.&nbsp;Sample output when running listing <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/executeblocking" shape="rect" title="Example 2.16. Using executeBlocking">2.16</a></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">INFO [vert.x-eventloop-thread-0] Offload - Tick
INFO [vert.x-worker-thread-0] Offload - Blocking code running
INFO [vert.x-worker-thread-0] Offload - Done!
INFO [vert.x-eventloop-thread-0] Offload - Blocking code result: Ok!
INFO [vert.x-eventloop-thread-0] Offload - Tick
INFO [vert.x-worker-thread-1] Offload - Blocking code running
INFO [vert.x-worker-thread-1] Offload - Done!
INFO [vert.x-eventloop-thread-0] Offload - Blocking code result: Ok!
INFO [vert.x-eventloop-thread-0] Offload - Tick
INFO [vert.x-worker-thread-2] Offload - Blocking code running
(...)</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="125" id="125" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="126" id="126" data-hash="24c2ed51dfde236713929f6606607f0f"> 
     <p>By default successive executeBlocking operations have their results being processed in the same order as the calls to executeBlocking.</p> 
    </div> 
    <div class="readable-text scrambled" refid="127" id="127" data-hash="00382b68fe4b3da19b89403eca439891"> 
     <p>There exists a variant of executeBlocking with an additional boolean parameter, and when set to false, results are being made available as event-loop events as soon as they are available, no matter what the order of executeBlocking calls was.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="128" id="128" data-hash="9291993fc597684c86c45178508bc425"> 
   <h2 class="calibre17" id="heading_id_15"><a class="pcalibre pcalibre1" id="so-what-is-really-in-a-verticle" shape="rect"></a>2.4 &nbsp;So what is really in a verticle?</h2> 
  </div> 
  <div class="readable-text scrambled" refid="129" id="129" data-hash="10c300f6bb6801081ccf79bfae5250a8"> 
   <p>So far we have seen how to write verticles, how to deploy and configure them, and how to deal with blocking code. By using informative logs in the samples, we have empirically witnessed elements of the Vert.x threading model.</p> 
  </div> 
  <div class="readable-text scrambled" refid="130" id="130" data-hash="9ba0fc16b75dcd35b74b3e585a0080d7"> 
   <p>Now is a good time to step back and dissect what is inside a verticle, and make sure you leave this chapter with a comprehensive understanding of how verticles work, and how to properly use them.</p> 
  </div> 
  <div class="readable-text" refid="131" id="131" data-hash="e5c80f1e3b69eb295b5cc17e3d4168e0"> 
   <h3 class="calibre29" id="heading_id_16"><a class="pcalibre pcalibre1" id="verticles-and-their-environment" shape="rect"></a>2.4.1 &nbsp;Verticles and their environment</h3> 
  </div> 
  <div class="browsable-container figure-container" refid="132" id="132" data-hash="63df16fb09d23a03cdcb77d3e2c47921"> 
   <h5 id="mm-verticle">Figure&nbsp;2.5.&nbsp;An event-loop verticle and its environment</h5> 
   <img alt="chapter2 verticle" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/chapter2-verticle.png" width="1105" loading="lazy" height="729" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="133" id="133" data-hash="3675548d500ff853c12b2a7e3b585249"> 
   <p>Figure 2.5 gives an overview of the relationships between a verticle and its environment.</p> 
  </div> 
  <div class="readable-text" refid="134" id="134" data-hash="340c753b2c38fb57dbb83b371a2afcd9"> 
   <p>A verticle object is essentially the combination of 2 objects:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="135" id="135" data-hash="7a97025a60e536338a574e5b1aacaeb0"> vrg Lotr.v tceninas rj sbonelg rx, znp<br> </li> 
   <li class="listitem readable-text scrambled" refid="136" id="136" data-hash="031f4fca7fe72e62ced8031d26e0c970"> z daetcidde ettocnx aensncit grsr lwsloa sgthiipdcna svteen kr sarlhedn.<br> </li> 
  </ol> 
  <div class="readable-text scrambled" refid="137" id="137" data-hash="64f18ff5ea156302022c63b3faad37d3"> 
   <p>The Vert.x instance exposes the core APIs for declaring event handlers. We have been using it already in the previous code samples with methods such as setTimer, setPeriodic, createHttpServer, deployVerticle, etc. The Vert.x instance is being shared by multiple verticles, and there is generally only 1 instance of Vertx per JVM process.</p> 
  </div> 
  <div class="readable-text scrambled" refid="138" id="138" data-hash="a953243dad1b9d511559157a82097052"> 
   <p>The context instance holds the access to the thread for executing handlers. Events may originate from various sources such as timers, database drivers, HTTP servers and more. As such, they are more often than not being triggered from other threads such as Netty accepting threads or timer threads.</p> 
  </div> 
  <div class="readable-text scrambled" refid="139" id="139" data-hash="c31cc87e7aeb4ebe476153da60db7612"> 
   <p>Event handling in user-defined callbacks happens through the context. The context instance allows calling the handler back on the verticle event-loop thread, hence respecting the Vert.x threading model.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="140" id="140" data-hash="ff4d8263a4766fa80fffa2575a7534af"> 
   <h5 id="mm-worker">Figure&nbsp;2.6.&nbsp;A worker verticle and its environment</h5> 
   <img alt="chapter2 worker" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/chapter2-worker.png" width="1160" loading="lazy" height="481" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="141" id="141" data-hash="7972d789476d4cc22a9839d66716fc62"> 
   <p>The case of worker verticles is not much different, except that handlers are being executed using one worker thread in a worker thread pool, as illustrated in figure 2.6. They are still verticles just like their event-loop counterparts and the code can assume single-threaded access. There is just no stability in which worker thread is going to be used for processing a worker verticle events.</p> 
  </div> 
  <div class="readable-text" refid="142" id="142" data-hash="08fce55fe60138e0a915c6facdef83e2"> 
   <h3 class="calibre29" id="heading_id_17"><a class="pcalibre pcalibre1" id="more-on-contexts" shape="rect"></a>2.4.2 &nbsp;More on contexts</h3> 
  </div> 
  <div class="readable-text scrambled" refid="143" id="143" data-hash="ce83fbff23f8dfbea24e5b292ad03235"> 
   <p>Context objects can be accessed using the getOrCreateContext() method from the Vertx class. While a context is mostly always associated to a verticle, it is possible to create event-loop contexts outside of a verticle. As the name of the method suggests:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="144" id="144" data-hash="258eb470b9db234055425912d905a662"> ialnclg <code class="code">getOrCreateContext()</code> mlxt c nxottce dthear vfej obr vnk lx c crteliev urretns gor exttnco, ihlwe<br> </li> 
   <li class="listitem readable-text scrambled" refid="145" id="145" data-hash="746703a8baba0ad1ddcc94d0bc166598"> gaclnli <code class="code">getOrCreateContext()</code> ltxm c nne-enoctxt ertdah eestrca c nwo cxotetn.<br> </li> 
  </ol> 
  <div class=" browsable-container listing-container" refid="146" id="146" data-hash="671cfe4c1307177dc8f7dd5c96581e91"> 
   <h5>Listing&nbsp;2.18.&nbsp;Creating contexts without a verticle</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">Vertx vertx = Vertx.vertx();

vertx.getOrCreateContext()
  .runOnContext(v -&gt; logger.info("ABC"));   #1

vertx.getOrCreateContext()
  .runOnContext(v -&gt; logger.info("123"));</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhlIGxhbWJkYSBpcyBiZWluZyBleGVjdXRlZCBvbiBhIFZlcnQueCBjb250ZXh0IHRocmVhZC4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="147" id="147" data-hash="e58d10285906f60006208a322acfee75"> 
   <p>Listing 2.18 gives an example where a global Vertx instance is being created, and 2 calls to getOrCreateContext are being made on the JVM process main thread. Each call is followed by a call to runOnContext, which allows running a block of code on the context thread.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="148" id="148" data-hash="0647a9510818157a7d061842ef62b5fe"> 
   <h5>Listing&nbsp;2.19.&nbsp;Sample output of running listing <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/standalone-context" shape="rect" title="Example 2.18. Creating contexts without a verticle">2.18</a></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">INFO [vert.x-eventloop-thread-1] ThreadsAndContexts - 123
INFO [vert.x-eventloop-thread-0] ThreadsAndContexts - ABC</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="149" id="149" data-hash="b21844f9d3ddbd811b536cd8d39f325c"> 
   <p>As we can see in listing 2.19, each context gets assigned to an event-loop.</p> 
  </div> 
  <div class="readable-text scrambled" refid="150" id="150" data-hash="c3c5a52cceb81384eb32803c77ddea88"> 
   <p>Context objects support more operations, such as holding context-wide arbitrary key/value data, and declaring exception handlers.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="151" id="151" data-hash="efd6bb26241c83f9b2dbd2068cd88024"> 
   <h5>Listing&nbsp;2.20.&nbsp;Using context data and exception handling</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">Vertx vertx = Vertx.vertx();
Context ctx = vertx.getOrCreateContext();
ctx.put("foo", "bar");

ctx.exceptionHandler(t -&gt; {
  if ("Tada".equals(t.getMessage())) {
    logger.info("Got a _Tada_ exception");
  } else {
    logger.error("Woops", t);
  }
});

ctx.runOnContext(v -&gt; {
  throw new RuntimeException("Tada");
});

ctx.runOnContext(v -&gt; {
  logger.info("foo = {}", (String) ctx.get("foo"));
});</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="152" id="152" data-hash="93701601e4e247ec8d574bd08ebe53ac"> 
   <p>Listing 2.20 provides an example where a foo key holds string bar, and an exception handler is being declared to catch and process exceptions while a handler is being executed on the event-loop thread.</p> 
  </div> 
  <div class="readable-text scrambled" refid="153" id="153" data-hash="5defe9c5313dd00c4e799e41b4e2a7a9"> 
   <p>Context data may be useful when event processing is spread across multiple classes. It is otherwise much simpler (and faster!) to use class fields.</p> 
  </div> 
  <div class="readable-text scrambled" refid="154" id="154" data-hash="a01a70910c0db2e1a25e6e84bc6356b1"> 
   <p>Exception handlers are important when event processing may throw exceptions. By default exceptions are simply being logged by Vert.x, but overriding a context exception handler is useful to perform custom actions for dealing with errors.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="155" id="155" data-hash="c528c176935495caa25f16ee72359b93"> 
   <h5>Listing&nbsp;2.21.&nbsp;Sample output of running listing <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/context-data-exceptions" shape="rect" title="Example 2.20. Using context data and exception handling">2.20</a></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">INFO [vert.x-eventloop-thread-0] ThreadsAndContexts - Got a _Tada_ exception
INFO [vert.x-eventloop-thread-0] ThreadsAndContexts - foo = bar</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="156" id="156" data-hash="176c3be9431e356f3cf1125771de8c33"> 
   <p>Running the code gives an output similar to that of listing 2.21.</p> 
  </div> 
  <div class="readable-text" refid="157" id="157" data-hash="31572d0ddd4ac3c5b4ce47b1f0ef261c"> 
   <h3 class="calibre29" id="heading_id_18"><a class="pcalibre pcalibre1" id="bridging-vert-x-and-non-vert-x-threading-models" shape="rect"></a>2.4.3 &nbsp;Bridging Vert.x and non-Vert.x threading models</h3> 
  </div> 
  <div class="readable-text scrambled" refid="158" id="158" data-hash="3f281d1a29a9d7f098309b5c086ed765"> 
   <p>You will probably not have to deal with Vert.x contexts when writing Vert.x applications. Still, there is one case where it makes most sense: when you have to use third-party code that has its own threading model, and you want to make it work properly with Vert.x.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="159" id="159" data-hash="9e6acb31b36d436e16269a63d1d8efd0"> 
   <h5>Listing&nbsp;2.22.&nbsp;Mixing different threading models</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class MixedThreading extends AbstractVerticle {
  private final Logger logger = LoggerFactory.getLogger(MixedThreading.class);

  @Override
  public void start() {
    Context context = vertx.getOrCreateContext();  #1
    new Thread(() -&gt; {
      try {
        run(context);
      } catch (InterruptedException e) {
        logger.error("Woops", e);
      }
    }).start();   #2
  }

  private void run(Context context) throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(1);
    logger.info("I am in a non-Vert.x thread");
    context.runOnContext(v -&gt; {   #3
      logger.info("I am on the event-loop");
      vertx.setTimer(1000, id -&gt; {
        logger.info("This is the final countdown");
        latch.countDown();
      });
    });
    logger.info("Waiting on the countdown latch...");
    latch.await();
    logger.info("Bye!");
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2UgZ2V0IHRoZSBjb250ZXh0IG9mIHRoZSB2ZXJ0aWNsZSBzaW5jZSBzdGFydCBpcyBydW5uaW5nIG9uIGFuIGV2ZW50LWxvb3AgdGhyZWFkLgojMiBXZSBzdGFydCBhIHBsYWluIEphdmEgdGhyZWFkLgojMyBydW5PbkNvbnRleHQgZW5zdXJlcyB3ZSBydW4gYmFjayBzb21lIGNvZGUgb24gdGhlIHZlcnRpY2xlIGV2ZW50LWxvb3AgdGhyZWFkLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="160" id="160" data-hash="a7436f4775af0b2fc941ab4a79732a53"> 
   <p>The code in listing 2.22 is a sample where a non-Vert.x thread is being created. By passing a context obtained from a verticle, we are able to execute some code back on the event-loop from some code running on a non-Vert.x thread. The logs in listing 2.23 show that.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="161" id="161" data-hash="9ec8159dad0c8cae3483d5639f225b62"> 
   <h5>Listing&nbsp;2.23.&nbsp;Sample output when running listing <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-2/v-10/mixed-threading" shape="rect" title="Example 2.22. Mixing different threading models">2.22</a></h5> 
   <div class="code-area-container"> 
    <pre class="code-area">INFO [Thread-3] MixedThreading - I am in a non-Vert.x thread
INFO [Thread-3] MixedThreading - Waiting on the countdown latch...
INFO [vert.x-eventloop-thread-0] MixedThreading - I am on the event-loop
INFO [vert.x-eventloop-thread-0] MixedThreading - This is the final countdown
INFO [Thread-3] MixedThreading - Bye!</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="162" id="162" data-hash="dd8905ed90d55fe22423f618e6db2fa3"> 
   <p>You can use the technique of having a verticle context and issuing calls to runOnContext whenever you need to integrate non-Vert.x threading models into your applications.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="163" id="163" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="164" id="164" data-hash="04ba604686206f15925c005838aa7911"> 
     <p>This example shows us another important property of contexts: they are being propagated when defining handlers. Indeed, the block of code run with runOnContext sets a timer handler after 1 second. We see that the handler is executed back with the same context as the one that was used for defining it.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="165" id="165" data-hash="5514aacc16dd3e2209a2a8e39c62b3a8"> 
   <p>The next chapter discusses the event-bus, the privileged way for verticles to communicate with each other and articulate event processing in a Vert.x application.</p> 
  </div> 
  <div class="readable-text" refid="166" id="166" data-hash="26fb8bf65e1f63427dff4db2036c1109"> 
   <h2 class="calibre17" id="heading_id_19"><a class="pcalibre pcalibre1" id="summary" shape="rect"></a>2.5 &nbsp;Summary</h2> 
  </div> 
  <ul class="itemizedlist"> 
   <li class="listitem readable-text" refid="167" id="167" data-hash="e583694987497cf0b26f3514b165d87d"> Verticles are the unit of event-processing in Vert.x.<br> </li> 
   <li class="listitem readable-text" refid="168" id="168" data-hash="6d90790439dc53a7837d3eb8c177b5e4"> Event-loop verticles process asynchronous I/O events and should be free of blocking and long-running operations.<br> </li> 
   <li class="listitem readable-text" refid="169" id="169" data-hash="8d2726a7216edae05841b148c0bcbf33"> Worker verticles can be used to process blocking I/O and long-running operations.<br> </li> 
   <li class="listitem readable-text" refid="170" id="170" data-hash="f16edfa621468001af8bce47edb75b2f"> It is possible to mix code with both Vert.x and non-Vert.x threads by using event-loop contexts.<br> </li> 
  </ul> 
  <div class="readable-text" refid="171" id="171" data-hash="931b403ff4ae9a5630406913788c2b80"> 
   <h2 class="calibre17" id="heading_id_20"><a class="pcalibre pcalibre1" id="references" shape="rect"></a>2.6 &nbsp;References</h2> 
  </div> 
  <div class="bibliodiv"> 
   <div class="bibliomixed"> <a class="pcalibre" id="d5e1282" shape="rect"></a> 
    <div class="readable-text" refid="172" id="172" data-hash="d507dd31f7edfc7aab66955c424e98f7"> 
     <p><span class="bibliomisc"><a class="pcalibre" id="ActorModel" shape="rect"></a>[ActorModel] Carl Hewitt, Peter Bishop, and Richard Steiger. 1973. A universal modular ACTOR formalism for artificial intelligence. In Proceedings of the 3rd international joint conference on Artificial intelligence (IJCAI'73). Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 235-245.</span></p> 
    </div> 
   </div> 
   <div class="bibliomixed"> <a class="pcalibre" id="d5e1285" shape="rect"></a> 
    <div class="readable-text" refid="173" id="173" data-hash="3d21d6ed47fe66b4047ef9bb7965f036"> 
     <p><span class="bibliomisc"><a class="pcalibre" id="Liskov88" shape="rect"></a>[Liskov88] B. Liskov and L. Shrira. 1988. Promises: linguistic support for efficient asynchronous procedure calls in distributed systems. In Proceedings of the ACM SIGPLAN 1988 conference on Programming language design and implementation (PLDI'88), R. L. Wexelblat (Ed.). ACM, New York, NY, USA, 260-267.</span></p> 
    </div> 
   </div> 
   <div class="bibliomixed"> <a class="pcalibre" id="d5e1288" shape="rect"></a> 
    <div class="readable-text" refid="174" id="174" data-hash="a6a29db9cd2baf3f8970eeda8c124a42"> 
     <p><span class="bibliomisc"><a class="pcalibre" id="LogbackDoc" shape="rect"></a>[LogbackDoc] The logback manual. Retrieved from <a class="pcalibre3 pcalibre" href="https://logback.qos.ch/manual/index.html" shape="rect">logback.qos.ch/manual/index.html</a></span></p> 
    </div> 
   </div> 
  </div>
 </body>
</html>