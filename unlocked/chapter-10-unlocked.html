<html>
 <head></head>
 <body>
  <div class="readable-text" refid="1" id="1" data-hash="6c464ea70d09a383844e13dfd0bdfd1d"> 
   <h1 class="chaptertitle" id="heading_id_28">10 <a class="pcalibre pcalibre1" id="persistent-state-management-with-databases" shape="rect"></a>Persistent state management with databases</h1> 
  </div> 
  <div class=" introduction-summary"> 
   <h3 class="intro-header">This chapter covers:</h3> 
   <ul> 
    <li class=" readable-text" refid="2" id="2" data-hash="46537723ec99c32b49a11eee57903fe7"> Storing data and authenticating users with MongoDB<br> </li> 
    <li class=" readable-text" refid="3" id="3" data-hash="56deab721ef8eda47c8e32b0e5d8d4f3"> Using PostgreSQL from Vert.x<br> </li> 
    <li class=" readable-text" refid="4" id="4" data-hash="8804cd4bf4ed286b4a719490a9df5c9b"> Testing strategies for integration tests of event-driven services that interact with databases<br> </li> 
   </ul> 
  </div> 
  <div class="readable-text" refid="5" id="5" data-hash="958802b8191ef6b07ad839d090350662"> 
   <p>Databases are essential in most applications as data needs to be stored, retrieved and queried. Databases can store all kinds of data such as application state, facts, or user credentials. There exist different types of databases on the market: some are generalist while others are specialized for certain types of use-cases, access patterns and data.</p> 
  </div> 
  <div class="readable-text" refid="6" id="6" data-hash="d58e62c36fe68bfa40025f2ed47601c3"> 
   <p>In this chapter we explore database and state management with Vert.x by diving into the implementation of the user and activity services. These services will allow us to use a document-oriented database (MongoDB) and a relational database (PostgreSQL). We will also see how to use MongoDB for authenticating users, and how to write integration tests for data-driven services.</p> 
  </div> 
  <div class="readable-text" refid="7" id="7" data-hash="ac35b65a5927229909a14e375ca52ad9"> 
   <h2 class="calibre17" id="heading_id_3"><a class="pcalibre pcalibre1" id="databases-and-vert-x" shape="rect"></a>10.1 &nbsp;Databases and Vert.x</h2> 
  </div> 
  <div class="readable-text" refid="8" id="8" data-hash="86b70086384ebaf349aaaa50c2e2711d"> 
   <p>Vert.x offers a wide range of clients to connect to data sources. These clients contain drivers to talk to servers, and may offer efficient connection management like connection pooling. This is useful to build all kinds of services, from API backed by a data source to integration services mixing data sources, messaging and APIs.</p> 
  </div> 
  <div class="readable-text" refid="9" id="9" data-hash="ba9eb4c74ce9bcee834dacce3b6ce988"> 
   <h3 class="calibre29" id="heading_id_4"><a class="pcalibre pcalibre1" id="what-the-eclipse-vert-x-stack-provides" shape="rect"></a>10.1.1 &nbsp;What the Eclipse Vert.x stack provides</h3> 
  </div> 
  <div class="readable-text" refid="10" id="10" data-hash="a261a44fa2100dccc300db09edc4f0d5"> 
   <p>The Eclipse Vert.x project provides the following data client modules, as given in table <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-10/v-10/stack-db-clients" shape="rect" title="Table 10.1. Data client modules supported by Eclipse Vert.x">10.1</a>.</p> 
  </div> 
  <div class=" browsable-container" refid="11" id="11" data-hash="9f41733001c6874d519b3682fb33d427"> 
   <h5>Table&nbsp;10.1.&nbsp;Data client modules supported by Eclipse Vert.x</h5> 
   <table border="1" class="contenttable" summary="Data client modules supported by Eclipse Vert.x" width="100%"> 
    <colgroup class="calibre28" span="1"> 
     <col class="col_" span="1" width="50%"> 
     <col class="col_" span="1" width="50%"> 
    </colgroup> 
    <tbody> 
     <tr class="calibre20"> 
      <td class="contenttable1" colspan="1" rowspan="1">Identifier</td> 
      <td class="contenttable1" colspan="1" rowspan="1">Description</td> 
     </tr> 
     <tr class="calibre20"> 
      <td class="contenttable2" colspan="1" rowspan="1"> <p><code class="code2">vertx-mongo-client</code></p> </td> 
      <td class="contenttable2" colspan="1" rowspan="1"> <p>MongoDB is a document-oriented database.</p> </td> 
     </tr> 
     <tr class="calibre20"> 
      <td class="contenttable2" colspan="1" rowspan="1"> <p><code class="code2">vertx-jdbc-client</code></p> </td> 
      <td class="contenttable2" colspan="1" rowspan="1"> <p>Supports any relational database that offers a JDBC driver.</p> </td> 
     </tr> 
     <tr class="calibre20"> 
      <td class="contenttable2" colspan="1" rowspan="1"> <p><code class="code2">vertx-pg-client</code> and <code class="code2">vertx-mysql-client</code></p> </td> 
      <td class="contenttable2" colspan="1" rowspan="1"> <p>Access PostgreSQL and MySQL relational databases through dedicated Vert.x reactive drivers.</p> </td> 
     </tr> 
     <tr class="calibre20"> 
      <td class="contenttable2" colspan="1" rowspan="1"> <p><code class="code2">vertx-redis-client</code></p> </td> 
      <td class="contenttable2" colspan="1" rowspan="1"> <p>Redis is versatile data structure store.</p> </td> 
     </tr> 
     <tr class="calibre20"> 
      <td class="contenttable2" colspan="1" rowspan="1"> <p><code class="code2">vertx-cassandra-client</code></p> </td> 
      <td class="contenttable2" colspan="1" rowspan="1"> <p>Apache Cassandra is a database tailored for very large volumes of data.</p> </td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <div class="readable-text scrambled" refid="12" id="12" data-hash="f9e155ea1f6998df0e5b98053c0dc669"> 
   <p>You can find drivers for other kinds of data sources in the larger Vert.x community, that is, beyond the scope of the project at the Eclipse Foundation.</p> 
  </div> 
  <div class="readable-text scrambled" refid="13" id="13" data-hash="038e23a4857731d374b8a7742438505a"> 
   <p>MongoDB is a popular document-oriented database. It is a good match with Vert.x since it manipulates JSON documents. Redis is an in-memory data structure store with configurable on-disk data snapshots that can be used as a cache, as a database, and as a message broker. Apache Cassandra is a multi-node, replicated database designed for storing huge amounts of data. Cassandra is well-suited for databases where size is measured in hundreds of terabytes or even petabytes. You can of course use it for just a few terabytes, but perhaps a more traditional database suffices in these cases.</p> 
  </div> 
  <div class="readable-text scrambled" refid="14" id="14" data-hash="b077dce10e07e9bfe8eafd64d426a62c"> 
   <p>Speaking of "traditional" relational databases, Vert.x can connect to anything for which there exists a JDBC driver. That being said JDBC is an older protocol based on a multi-threaded design and blocking I/O. The JDBC support in Vert.x offloads database calls to worker thread pools, and pushes results back to event-loop contexts. This is to avoid blocking event-loops since JDBC calls do block. Of course this design limits scalability as worker threads are needed, but for moderate workloads this should be fine.</p> 
  </div> 
  <div class="readable-text scrambled" refid="15" id="15" data-hash="aa1569a50492766abde1592c1d693093"> 
   <p>Now if you use PostgreSQL or MySQL then Vert.x provides its own reactive drivers. These drivers implement the network protocols of each database servers, and they are built in a purely asynchronous fashion using Netty, the networking foundation of Vert.x. The drivers offer excellent performance, both in terms of latency and concurrent connections. They are also very stable and implement the current protocols and features of the databases. You should prefer the Vert.x reactive driver clients for PostgreSQL and MySQL, and use the JDBC client when you need to connect to other databases.</p> 
  </div> 
  <div class="readable-text scrambled" refid="16" id="16" data-hash="ed60b2fa840be6ff6cfc3708ead293ad"> 
   <p>If you are looking for a solid database then PostgreSQL is probably a good bet. PostgreSQL is versatile and has been used in all sorts of small and large scale projects over the years. You can of course use it as a traditional relational database, but it also supports JSON documents as first-class objects, and geographic objects through the PostGIS extension.</p> 
  </div> 
  <div class="readable-text" refid="17" id="17" data-hash="1c6550530e769f59ce7b53440aa8856b"> 
   <h3 class="calibre29" id="heading_id_5"><a class="pcalibre pcalibre1" id="a-note-on-data-object-mapping-and-why-you-may-not-always-need-it" shape="rect"></a>10.1.2 &nbsp;A note on data / object mapping, and why you may not always need it</h3> 
  </div> 
  <div class="readable-text scrambled" refid="18" id="18" data-hash="25fa6e0a0925266e7c3c778cb52a0f48"> 
   <p>Before we dive into the user profile service design and implementation with MongoDB, I would like to quickly discuss certain established idioms of enterprise Java development, and explain why in search of simplicity and efficiency the code in this chapter deviates on-purpose from supposed "best practices".</p> 
  </div> 
  <div class="readable-text scrambled" refid="19" id="19" data-hash="28abf1fb47436c3ca238dfe53779d302"> 
   <p>The code of the 10k steps challenge may surprise you because it does not perform object data mapping, where any data has to be mapped to some Java object model that represent the application domain (e.g., data transfer objects [DTO]). For instance some JSON data representing a pedometer update would be mapped to some DeviceUpdate Java class before any further processing is being made. Here we will directly manipulate data in JsonObject instances as they flow between HTTP, Kafka and database interfaces. We will not map, say, device update JSON data to DeviceUpdate and we will "simply" work with the JsonObject representation of that data instead.</p> 
  </div> 
  <div class="readable-text scrambled" refid="20" id="20" data-hash="817d266dd27612ab510a20ccea641ab4"> 
   <p>Of course Vert.x does allow you to do data mapping from and to Java classes, but unless the object model actually contains some significant business logic or can be leveraged by some processing in a third-party library, I see little value in doing any form of data binding. I advocate such a design because:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="21" id="21" data-hash="2ba50df70b8faa2a2fbc617580eaec00"> jr vsase gc tlem wiginrt escsals urrs ogsv nk lauiyntcntfoi xpecet ingoepxs rvatili esttger sbn streets,<br> </li> 
   <li class="listitem readable-text scrambled" refid="22" id="22" data-hash="9b4283757b243683423c192af1e3055e"> rj dvaiso aenruscseny ctejob calnioatol lx teojscb wrdj ytplyliac hrsto meiilfet (x.y., rvu aeniplsf lx rnssgpoiec c HCCF eustreq),<br> </li> 
   <li class="listitem readable-text scrambled" refid="23" id="23" data-hash="236c540bbc219bfdf94be7a9e61b5e4c"> gsrc jc rvn awaysl zxbc kr zbm kr zn tecjbo elmdo, nsb ehd qsm vnr vg eistnetrde jn fzf xdr hrsz rpq crqi comv ltedscee neteisr,<br> </li> 
   <li class="listitem readable-text scrambled" refid="24" id="24" data-hash="83c676531a998a16a00f70775aeb31b8"> jn vur azzx el otlirnalae detaabass pxr jbotec cqn oru ldesom ogvz vaom wfkf-knnow steahsicmm <a class="pcalibre para2" href="/book/vertx-in-action/chapter-10/v-10/Neward06" shape="rect">[Neward06]</a> cyrr nas urselt nj xlpcome maipsngp usn yzg merapcronfe vyh re seecixvse ersiqeu,<br> </li> 
   <li class="listitem readable-text scrambled" refid="25" id="25" data-hash="05ad7a937c95831767102595ba949224"> rj uaevntylle adlse er sxuv rzur ja vmxt <em class="calibre9">aucifltnno</em>.<br> </li> 
  </ol> 
  <div class="readable-text scrambled" refid="26" id="26" data-hash="1ca2ada20922314c3be48a0415f5660d"> 
   <p>In case of doubt always ask yourself whether you actually need an object model, or whether the data representation is good enough for the processing work that you are doing. If your object model consists of nothing but getters and setters then perhaps it’s a good sign that (at least initially) you don’t need it.</p> 
  </div> 
  <div class="readable-text scrambled" refid="27" id="27" data-hash="5fda509f19b61557fb1c0c5332a89a53"> 
   <p>Let us now dive into using MongoDB in the user profile service.</p> 
  </div> 
  <div class="readable-text" refid="28" id="28" data-hash="ec22400a13f745cf348c5f0b45bfc4fe"> 
   <h2 class="calibre17" id="heading_id_6"><a class="pcalibre pcalibre1" id="user-profile-service-with-mongodb" shape="rect"></a>10.2 &nbsp;User profile service with MongoDB</h2> 
  </div> 
  <div class="readable-text scrambled" refid="29" id="29" data-hash="6a0652f12f7263bf33a7179e1e630e09"> 
   <p>The user profile service manages user data such as name, email, city and is also use to authenticate a user against login / password credentials. This service is used by the services that need to retrieve and correlate data against user information.</p> 
  </div> 
  <div class="readable-text" refid="30" id="30" data-hash="045f9ff2a5c3961ad7d704ef98c09208"> 
   <p>The user service makes use of MongoDB for 2 purposes:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="31" id="31" data-hash="f34a25d144ed38f552565259f3b316a1"> ntosrgi coyt qrss: eensuarm, rowassdp, melai, jzrd, cideev eefrdiinti zun heehwtr pcsr uholsd rpaaep jn uicbpl ngnrksia, cnq<br> </li> 
   <li class="listitem readable-text scrambled" refid="32" id="32" data-hash="4f644aeb56fe8006dda37739df4ba7f5"> nthtiingteacua sesur nsaagit s reumnase uhfa dsswpoar nooimatibnc.<br> </li> 
  </ol> 
  <div class="readable-text scrambled" refid="33" id="33" data-hash="84793bf119dbb83f76a2f9769e37e2ff"> 
   <p>MongoDB is a good fit because it is a document database, so each user can be represented as a document. We are going to use the vertx-mongo-client module to connect to MongoDB instances, and we are also going to use the vertx-auth-mongo module for doing authentication.</p> 
  </div> 
  <div class="readable-text" refid="34" id="34" data-hash="2958f7920be906edaa0a5a6a3e43f837"> 
   <h3 class="calibre29" id="heading_id_7"><a class="pcalibre pcalibre1" id="data-model" shape="rect"></a>10.2.1 &nbsp;Data model</h3> 
  </div> 
  <div class="readable-text scrambled" refid="35" id="35" data-hash="056dadf142efe0e894db03746a1dc1a6"> 
   <p>The vertx-auth-mongo module is a "turn-key" solution for doing user authentication on top of a MongoDB database, as it manages all the intricacies of properly storing and retrieving credentials. It implements the common authentication interface of module vertx-auth-common. It especially deals with storing cryptographic hashes of passwords with a salt value, because storing actual passwords is never a good idea. According to the conventions defined in the vertx-auth-mongo module, there is a document for each user in the target database with the following entries:</p> 
  </div> 
  <ul class="itemizedlist"> 
   <li class="listitem readable-text scrambled" refid="36" id="36" data-hash="9a0b21b3c80f0e754a313072074a15c8"> <code class="code">username</code>: s gsrint lkt vry eearmuns,<br> </li> 
   <li class="listitem readable-text scrambled" refid="37" id="37" data-hash="a0a157d29086bf20695b467df3d46147"> <code class="code">salt</code>: s ndmaro yrcz itgnsr ucxh rk useerc krb osawrpsd,<br> </li> 
   <li class="listitem readable-text scrambled" refid="38" id="38" data-hash="82cc2704f08542aee4c8a9993ea2f6a7"> <code class="code">password</code>: z igntrs syvm xl cuotimpng rqv SHB-512 cadb vltm bxr tluaac aorsswpd ahdf urx <code class="code">salt</code> ulvae,<br> </li> 
   <li class="listitem readable-text scrambled" refid="39" id="39" data-hash="32c22c7922ac53009f8c6f44afbb3be7"> <code class="code">roles</code>: cn rarya lx tngsris gfiiednn <em class="calibre9">lesro</em> (o.p., nr"stao"rtimida),<br> </li> 
   <li class="listitem readable-text scrambled" refid="40" id="40" data-hash="8dac0e40fbcdcc018978682dced56698"> <code class="code">permissions</code>: sn yrraa lx trsnsig egifdinn <em class="calibre9">rmspisoiens</em> (k.q., aeccc"_n_as"sbeat).<br> </li> 
  </ul> 
  <div class="readable-text scrambled" refid="41" id="41" data-hash="5531b9b64efa76e36aec8771efff42c8"> 
   <p>In our case we are not going to use roles and permissions since all users will be equal, and these entries will be empty arrays. We will not have to deal with the subtleties of handling salts and password hashing as this is taken care of by the authentication module.</p> 
  </div> 
  <div class="readable-text scrambled" refid="42" id="42" data-hash="fc0ac4613ee9ffccddbe8b10f1bd0950"> 
   <p>While this data model is prescribed by vertx-auth-mongo, nothing precludes us from adding more fields to the documents that represent users. We thus add the following entries:</p> 
  </div> 
  <ul class="itemizedlist"> 
   <li class="listitem readable-text scrambled" refid="43" id="43" data-hash="f4bb4560ec947b0c589e6f7106608894"> <code class="code">city</code>: s nirtgs tel qrx yzvt jsur,<br> </li> 
   <li class="listitem readable-text scrambled" refid="44" id="44" data-hash="a8a056223b07c1842ddbe1006db322b9"> <code class="code">deviceId</code>: s gstrni klt rou reeptdoem ceevdi driinefiet,<br> </li> 
   <li class="listitem readable-text scrambled" refid="45" id="45" data-hash="f3ee690a07c2e601b5b659dfe221b628"> <code class="code">email</code>: s risngt etl grx toch ameli,<br> </li> 
   <li class="listitem readable-text scrambled" refid="46" id="46" data-hash="cb420d47839bada1c3cfadddd5818e76"> <code class="code">makePublic</code>: s anboelo rk inadecit ewhert pvr vaht awtns kr eapapr nj cliubp nrankgis xt nxr.<br> </li> 
  </ul> 
  <div class="readable-text scrambled" refid="47" id="47" data-hash="b83562d7c59327dfad03e23990636681"> 
   <p>We also enforce 2 integrity constraints with MongoDB indexes: both username and deviceId must be unique to a document. This avoids duplicate user names as well as 2 users having the same device. This will interestingly pose to be a correctness challenge when registering new users because we will not be able to use any transaction mechanism, so we will need to rollback partial data inserts when the deviceId uniqueness constraint will prevent a duplicate insert.</p> 
  </div> 
  <div class="readable-text scrambled" refid="48" id="48" data-hash="c9aa3e349426c56c0320057021145afa"> 
   <p>Let us now see how to use both the Vert.x MongoDB client and the Vert.x authentication support.</p> 
  </div> 
  <div class="readable-text" refid="49" id="49" data-hash="986d874330d7f87655586c88202e73c6"> 
   <h3 class="calibre29" id="heading_id_8"><a class="pcalibre pcalibre1" id="user-profile-api-verticle-and-initialization" shape="rect"></a>10.2.2 &nbsp;User profile API verticle and initialization</h3> 
  </div> 
  <div class="readable-text scrambled" refid="50" id="50" data-hash="5307bd59609541f5fad399807e4b2fd8"> 
   <p>The UserProfileApiVerticle class exposes the HTTP API for the user profile service. It holds 2 important fields:</p> 
  </div> 
  <ul class="itemizedlist"> 
   <li class="listitem readable-text scrambled" refid="51" id="51" data-hash="ce309a2455966abb806507a8f296da88"> <code class="code">mongoClient</code> lx vgrg <code class="code">MongoClient</code> rk necncot xr s WvnvhNR servre, bnc<br> </li> 
   <li class="listitem readable-text scrambled" refid="52" id="52" data-hash="a6c4e7d924e9b419227e8662d9c2c483"> <code class="code">authProvider</code> xl rqkg <code class="code">MongoAuth</code> rk mrorefp thaaniteiotnuc gnusi WvxdnUR.<br> </li> 
  </ul> 
  <div class="readable-text scrambled" refid="53" id="53" data-hash="c57723bf2e88b6d0e511fb25ef894067"> 
   <p>We initialize these fields from the verticle initialization method rxStart (since we use RxJava), as given in listing 10.1.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="54" id="54" data-hash="086278f1703fee7cfa19c12d22efaa15"> 
   <h5>Listing&nbsp;10.1.&nbsp;Initializing the MonbgoDB client and authentication provider</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">mongoClient = MongoClient.createShared(vertx, mongoConfig()); #1

JsonObject authConfig = new JsonObject();   #2
authProvider = MongoAuth.create(mongoClient, authConfig);</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgQ3JlYXRlcyBhIGNsaWVudCBiYXNlZCBvbiBzb21lIGNvbmZpZ3VyYXRpb24uCiMyIFdlIGhhdmUgZW1wdHkgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgZGV0YWlscy4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="55" id="55" data-hash="fdc9b3aaa06f414db1d9cfee6b62a15b"> 
   <p>The authentication provider piggy-backs onto the MongoDB client instance, which is configured as in listing 10.2. We pass empty configuration options for the authentication provider as we follow the conventions of the Vert.x MongoDB authentication module.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="56" id="56" data-hash="7b3edc27e0a63ff6bbcb6ab155627914"> 
   <h5>Listing&nbsp;10.2.&nbsp;MongoDB client configuration method</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private JsonObject mongoConfig() {
  return new JsonObject()
    .put("host", "localhost")   #1
    .put("port", 27017)
    .put("db_name", "profiles");    #2
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2Ugd2lsbCBiZSB0ZXN0aW5nIGxvY2FsbHkuCiMyIHByb2ZpbGVzIGlzIHRoZSBkYXRhYmFzZSBuYW1lLCBidXQgd2UgY291bGQgZXF1YWxseSB1c2Ugc29tZXRoaW5nIGVsc2Uu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="57" id="57" data-hash="52f599a59192abaa1072a8814cfd62d0"> 
   <p>Since we expose a HTTP API, we use a Vert.x web router to configure the various routes to be handled by the service, given in listing 10.3.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="58" id="58" data-hash="c81566e27729f9205bfea5d8ea31445d"> 
   <h5>Listing&nbsp;10.3.&nbsp;User profile service HTTP routing</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">Router router = Router.router(vertx);
BodyHandler bodyHandler = BodyHandler.create();
router.post().handler(bodyHandler);
router.put().handler(bodyHandler);
router.post("/register")
  .handler(this::validateRegistration)  #1
  .handler(this::register);
router.get("/:username").handler(this::fetchUser);
router.put("/:username").handler(this::updateUser);
router.post("/authenticate").handler(this::authenticate);
router.get("/owns/:deviceId").handler(this::whoOwns);</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2Ugc3BsaXQgdGhlIHByb2Nlc3NpbmcgbG9naWMgaW4gMiBjaGFpbmVkIGhhbmRsZXJzLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="59" id="59" data-hash="f8160594a8839b495d8f2cfa73540252"> 
   <p>We can note that we use 2 chained handlers for the registration, as we use a first handler for data validation, and a second handler for the actual processing logic. But what is exactly in the validation logic?</p> 
  </div> 
  <div class="readable-text" refid="60" id="60" data-hash="81c2f06e81a186569b85ee197548d5ad"> 
   <h3 class="calibre29" id="heading_id_9"><a class="pcalibre pcalibre1" id="validating-user-input" shape="rect"></a>10.2.3 &nbsp;Validating user input</h3> 
  </div> 
  <div class="readable-text scrambled" refid="61" id="61" data-hash="ee2947d71ec717f75c1a8e39b801464d"> 
   <p>Registration is a critical step, so we must ensure that data is valid. We must check that the incoming data (a JSON document) contains all required fields, and that they are all valid. For instance we need to check that an email is actually an email, and that a username is not empty and does not contain unwanted characters.</p> 
  </div> 
  <div class="readable-text scrambled" refid="62" id="62" data-hash="d14d02ae632233aba6a9136010c82108"> 
   <p>The validateRegistration method of listing 10.4 delegates to helper methods anyRegistrationFieldIsMissing and anyRegistrationFieldIsWrong to perform validation.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="63" id="63" data-hash="215c37c7c335519944d3f03658448956"> 
   <h5>Listing&nbsp;10.4.&nbsp;The registration validation method</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private void validateRegistration(RoutingContext ctx) {
  JsonObject body = jsonBody(ctx);
  if (anyRegistrationFieldIsMissing(body) || anyRegistrationFieldIsWrong(body)) {
    ctx.fail(400);  #1
  } else {
    ctx.next(); #2
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgUmVnaXN0cmF0aW9uIGZhaWxlZCwgd2UgZW5kIHRoZSBIVFRQIHJlcXVlc3Qgd2l0aCBzdGF0dXMgY29kZSA0MDAuCiMyIFRoZSBuZXh0IGhhbmRsZXIgaW4gdGhlIGNoYWluIGlzIGNhbGxlZC4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="64" id="64" data-hash="d7431e3739e110bc9b1d8ebdd303e929"> 
   <p>When any validation steps fails then we respond with a 400 HTTP status code, else we call the next handler, which in our case will be the register method. The implementation of method anyRegistrationFieldIsMissing is quite simple as we check that the provided JSON document contains the required fields, as shown in listing 10.5.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="65" id="65" data-hash="98d6e7e0c0317750e615cdd692de6de0"> 
   <h5>Listing&nbsp;10.5.&nbsp;Checking for missing JSON fields</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private boolean anyRegistrationFieldIsMissing(JsonObject body) {
  return !(body.containsKey("username") &amp;&amp;  #1
    body.containsKey("password") &amp;&amp;
    body.containsKey("email") &amp;&amp;
    body.containsKey("city") &amp;&amp;
    body.containsKey("deviceId") &amp;&amp;
    body.containsKey("makePublic"));
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgQ2hlY2sgYWxsIGZpZWxkcyBhcmUgcHJlc2VudC4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="66" id="66" data-hash="1867176578620a2fd3465bb1253868e2"> 
   <p>Method anyRegistrationFieldIsWrong delegates checks to regular expressions with the implementation of listing 10.6.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="67" id="67" data-hash="5dfa428a964674e5d2eb8fe1a6d17222"> 
   <h5>Listing&nbsp;10.6.&nbsp;Validating specific fields</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private final Pattern validUsername = Pattern.compile("\\w[\\w+|-]*");     #1
// (...)
private boolean anyRegistrationFieldIsWrong(JsonObject body) {
  return !validUsername.matcher(body.getString("username")).matches() ||   #2
    !validEmail.matcher(body.getString("email")).matches() ||
    body.getString("password").trim().isEmpty() ||  #3
    !validDeviceId.matcher(body.getString("deviceId")).matches();
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgUmVndWxhciBleHByZXNzaW9uIGZvciB2YWxpZCB1c2VybmFtZXMgbGlrZSBhYmMsIGEtYi1jLCBldGMuCiMyIFJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGluZy4KIzMgdHJpbSByZW1vdmVzIHdoaXRlIHNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgc3RyaW5nLCB0aGVuIGNoZWNrIGZvciBlbXB0aW5lc3Mu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="68" id="68" data-hash="53d6ff2db2b916b336c3d5d807f75a37"> 
   <p>The validDeviceId regular expression is the same as validUsername. Validating an email address (validEmail) is a more sophisticated regular expression. We chose to use one of the safe regular expressions from [OWASP] for that purpose.</p> 
  </div> 
  <div class="readable-text scrambled" refid="69" id="69" data-hash="8d9126c15b8f7c4bf20cb10969af45e4"> 
   <p>Now that we have validated data, it is time to actually register users.</p> 
  </div> 
  <div class="readable-text" refid="70" id="70" data-hash="5c65ac8da5e955b6d6a5d31a92edb66e"> 
   <h3 class="calibre29" id="heading_id_10"><a class="pcalibre pcalibre1" id="adding-users-in-mongodb" shape="rect"></a>10.2.4 &nbsp;Adding users in MongoDB</h3> 
  </div> 
  <div class="readable-text" refid="71" id="71" data-hash="c45f893bbb282af8958e1345b6146e76"> 
   <p>Inserting a new user in the database requires 2 steps:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="72" id="72" data-hash="e32638afeb371afff40f6ee33400384c"> ow nbkv xr vzc roy hocatunteinita eiodprvr kr tesrin c wkn cdtv, cs rj ffjw zkfs pskf wjyr rehot sespatc kfej isgnhah dpwssoras syn viganh c frcz eaulv, nyrk<br> </li> 
   <li class="listitem readable-text scrambled" refid="73" id="73" data-hash="e4945a87b756f2bfee813a98402ec06e"> wk unov kr udpdaet xrg otdc mdouetnc rv qbs atxre siefdl curr sot krn edrqruie db ory oiaietnnthatcu rrepiovd eshcma.<br> </li> 
  </ol> 
  <div class="readable-text scrambled" refid="74" id="74" data-hash="82dcab7c48454a0ebfe6ddae762d2129"> 
   <p>Since this is a 2 steps data insert and we cannot use any transaction management facility, we need to care about data integrity ourselves, as shown in figure 10.1.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="75" id="75" data-hash="edd3ad8004ea0da293d4ef42cb407f39"> 
   <h5 id="add-user">Figure&nbsp;10.1.&nbsp;Steps to successfully add a user</h5> 
   <img alt="add user" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/add-user.png" width="1145" loading="lazy" height="728" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="76" id="76" data-hash="777290be940c59cce71d37e3faf5f145"> 
   <p>Fortunately RxJava makes the error management declarative, so we won’t have to deal with nested conditionals of asynchronous operations, which would be complicated to do with callbacks or promises / futures.</p> 
  </div> 
  <div class="readable-text scrambled" refid="77" id="77" data-hash="048c479dbed749a8f56d1ea91be73d91"> 
   <p>The register method starts with extracting the JSON payload from the HTTP request, then the username and password of the user to create, as shown in listing 10.7.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="78" id="78" data-hash="3bee84bdc7c27db6c99796a02a488a6c"> 
   <h5>Listing&nbsp;10.7.&nbsp;Preamble of the register method</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private void register(RoutingContext ctx) {
  JsonObject body = jsonBody(ctx);  #1
  String username = body.getString("username");
  String password = body.getString("password");

  authProvider
      .rxInsertUser(username, password, emptyList(), emptyList()) #2
  // (...)
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgRXh0cmFjdCB0aGUgSlNPTiBib2R5LgojMiBJbnNlcnQgYSBuZXcgdXNlci4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="79" id="79" data-hash="5942af74f1566d880b4ecb8b690f900d"> 
   <p>Remember that register is called after validation, so we expect the JSON data to be good. We pass the authentication provider the username, password, and 2 empty lists for roles and permissions. It then populates the database with a new document. We then have to run a query to update the newly-created document, and append new entries. The MongoDB query is given in listing 10.8 and is represented as a JSON object.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="80" id="80" data-hash="e9e9d123c444b1e7bf888955d7feab3f"> 
   <h5>Listing&nbsp;10.8.&nbsp;MongoDB query to update a new user</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">JsonObject extraInfo = new JsonObject()
  .put("$set", new JsonObject() #1
    .put("email", body.getString("email"))
    .put("city", body.getString("city"))
    .put("deviceId", body.getString("deviceId"))
    .put("makePublic", body.getBoolean("makePublic")));</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhpcyBpcyB0aGUgJHNldCBvcGVyYXRvciBmcm9tIE1vbmdvREIu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="81" id="81" data-hash="3abb447fc5de32892b0e38aa251b11db"> 
   <p>We must thus chain the rxInsertUser operation with a MongoDB update query, knowing that rxInsertUser returns a Single&lt;String&gt; where the value is the identifier of the new document. Listing 10.9 has the complete user addition processing with RxJava.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="82" id="82" data-hash="bc0c5ff2f23a40ef4456ed309347009c"> 
   <h5>Listing&nbsp;10.9.&nbsp;Complete user addition processing with RxJava</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">authProvider
  .rxInsertUser(username, password, emptyList(), emptyList())   #1
  .flatMapMaybe(docId -&gt; insertExtraInfo(extraInfo, docId))     #2
  .ignoreElement()
  .subscribe(
    () -&gt; completeRegistration(ctx),    #3
    err -&gt; handleRegistrationError(ctx, err));  #4</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgQXV0aGVudGljYXRpb24gcHJvdmlkZXIgaW5zZXJ0IHF1ZXJ5LgojMiBVcGRhdGUgcXVlcnkuCiMzIEhUVFAgMjAwLgojNCBEZWFsIHdpdGggdGhlIGVycm9yLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="83" id="83" data-hash="993aef45f65566e5edce0465c9871560"> 
   <p>The flatMapMaybe operator allows us to chain the 2 queries. Method insertExtraInfo is given in listing 10.10 and returns a MaybeSource, because finding and updating a document may not hold a result if no matching document was found.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="84" id="84" data-hash="c50be18f83d393aca7a7099027917199"> 
   <h5>Listing&nbsp;10.10.&nbsp;Implementation of the insertExtraInfo method</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private MaybeSource&lt;? extends JsonObject&gt; insertExtraInfo(JsonObject extraInfo, String docId) {
  JsonObject query = new JsonObject().put("_id", docId);
  return mongoClient
    .rxFindOneAndUpdate("user", query, extraInfo)   <a class="pcalibre pcalibre1" id="CO10-1" shape="rect"></a><span class="pcalibre1">#1</span>
    .onErrorResumeNext(err -&gt; {
      return deleteIncompleteUser(query, err);  <a class="pcalibre pcalibre1" id="CO10-2" shape="rect"></a><span class="pcalibre1">#2</span>
    });
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgRmluZCBhbmQgdXBkYXRlIGEgZG9jdW1lbnQuCiMyIE1hbnVhbCByb2xsYmFjay4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="85" id="85" data-hash="bb61f432d7229c043c67d78489460c49"> 
   <p>Note that the update query can fail, for instance because another user has already registered a device with the same identifier. In this case we need to manually rollback and remove the document that was created by the authentication provider, because otherwise we would have an incomplete document in the database. Listing 10.11 holds the implementation of the deleteIncompleteUser method.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="86" id="86" data-hash="a9814da1062284a0c293769595aafc1c"> 
   <h5>Listing&nbsp;10.11.&nbsp;Implementation of the deleteIncompleteUser method</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private boolean isIndexViolated(Throwable err) {
  return err.getMessage().contains("E11000");   <a class="pcalibre pcalibre1" id="CO11-1" shape="rect"></a><span class="pcalibre1">#1</span>
}

private MaybeSource&lt;? extends JsonObject&gt; deleteIncompleteUser(JsonObject query, Throwable err) {
  if (isIndexViolated(err)) {
    return mongoClient
      .rxRemoveDocument("user", query)  <a class="pcalibre pcalibre1" id="CO11-2" shape="rect"></a><span class="pcalibre1">#2</span>
      .flatMap(del -&gt; Maybe.error(err)); <a class="pcalibre pcalibre1" id="CO11-3" shape="rect"></a><span class="pcalibre1">#3</span>
  } else {
    return Maybe.error(err);  <a class="pcalibre pcalibre1" id="CO11-4" shape="rect"></a><span class="pcalibre1">#4</span>
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhpcyBpcyB0aGUgdGVjaG5pY2FsIGNvZGUgZm9yIGFuIGluZGV4IGNvbnN0cmFpbnQgdmlvbGF0aW9uLgojMiBSZW1vdmUgdGhlIGRvY3VtZW50LgojMyBSZXBsYWNlIHRoZSByZXN1bHQgd2l0aCB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uIGFuZCBwcm9wYWdhdGUgaXQuCiM0IEl0IGlzIGFub3RoZXIgZXJyb3IgYW5kIHdlIHByb3BhZ2F0ZSBpdC4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="87" id="87" data-hash="687af2e28dd3371d92fafc376b439a8d"> 
   <p>We need to rely on a technical code in an exception message to distinguish between index violation errors and other types of errors. In the first case the previous data has to be removed because we want to deal with it and recover, in the second case this is another error and we cannot do much so we propagate it.</p> 
  </div> 
  <div class="readable-text scrambled" refid="88" id="88" data-hash="24521f7b580fc6aaf5bbae16a6504459"> 
   <p>Finally the handleRegistrationError given in listing 10.12 method needs to inspect the error to respond with the appropriate HTTP status code.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="89" id="89" data-hash="9ae98313a2c02b56d93936d10598d757"> 
   <h5>Listing&nbsp;10.12.&nbsp;Implementation of the handleRegistrationError method</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private void handleRegistrationError(RoutingContext ctx, Throwable err) {
  if (isIndexViolated(err)) {
    logger.error("Registration failure: {}", err.getMessage());
    ctx.fail(409);  #1
  } else {
    logger.error("Woops", err);
    ctx.fail(500); #2
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhlIGVycm9yIGlzIGJlY2F1c2UgdGhlIHVzZXIgcHJvdmlkZWQgYW4gZXhpc3RpbmcgdXNlcm5hbWUgb3IgZGV2aWNlIGlkZW50aWZpZXIuCiMyIFRoaXMgaXMgYSB0ZWNobmljYWwgZXJyb3Iu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="90" id="90" data-hash="733f6540d6611378907d25ba8b08c02f"> 
   <p>It is important to notify the requester whether the request failed because the username or device identifier has already been taken, or whether it failed due to some technical error. In one case the error is the fault of the requester, in the other case the service is the culprit and the requester can try again later.</p> 
  </div> 
  <div class="readable-text" refid="91" id="91" data-hash="725ca454ec8bc55f74b8d50fd64ec9e8"> 
   <h3 class="calibre29" id="heading_id_11"><a class="pcalibre pcalibre1" id="authenticating-a-user" shape="rect"></a>10.2.5 &nbsp;Authenticating a user</h3> 
  </div> 
  <div class="readable-text scrambled" refid="92" id="92" data-hash="234ba409927cf3efea4c9d2ff8d7d23d"> 
   <p>Authenticating a user against a username and password is very simple. All we need to do is querying the authentication provider, which returns a io.vertx.ext.auth.User instance on success. In our case we are not interested in querying permissions or roles, so all we want to do is check that authentication succeeded.</p> 
  </div> 
  <div class="readable-text scrambled" refid="93" id="93" data-hash="51267afbeb049e27b5b802b5b492e3ce"> 
   <p>Assuming that a HTTP POST request sent to /authenticate has a JSON body with username and password fields, we can perform the authentication request as in listing 10.13.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="94" id="94" data-hash="80954f13b0ffc19577108fe72f8a1252"> 
   <h5>Listing&nbsp;10.13.&nbsp;Authenticating a user</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private void authenticate(RoutingContext ctx) {
  authProvider.rxAuthenticate(jsonBody(ctx))  #1
    .subscribe(
      user -&gt; completeEmptySuccess(ctx),
      err -&gt; handleAuthenticationError(ctx, err));
}

private void completeEmptySuccess(RoutingContext ctx) {
  ctx.response().setStatusCode(200).end();  #2
}

private void handleAuthenticationError(RoutingContext ctx, Throwable err) {
  logger.error("Authentication problem {}", err.getMessage());
  ctx.response().setStatusCode(401).end();  #3
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgQXV0aGVudGljYXRpb24gbWV0aG9kLgojMiBTdWNjZXNzLgojMyBSZXBvcnQgYW4gYXV0aGVudGljYXRpb24gZmFpbHVyZS4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="95" id="95" data-hash="2ecc9ba8f6c49d3bcf6453b2a3374ec6"> 
   <p>The result of an authentication request is a User or an exception if it failed. Depending on the outcome we end the HTTP request with a 200 or 401 status code.</p> 
  </div> 
  <div class="readable-text" refid="96" id="96" data-hash="ddfdbc275288f48a6967288f69e5394a"> 
   <h3 class="calibre29" id="heading_id_12"><a class="pcalibre pcalibre1" id="fetching-a-user-data" shape="rect"></a>10.2.6 &nbsp;Fetching a user data</h3> 
  </div> 
  <div class="readable-text scrambled" refid="97" id="97" data-hash="40dd660dc7724a5611c70c556699e0e6"> 
   <p>HTTP GET requests to /username must return the data associated to that user (e.g., /foo, /bar, etc). To do that we need to prepare a MongoDB query, and return the data as a JSON response.</p> 
  </div> 
  <div class="readable-text scrambled" refid="98" id="98" data-hash="0ed22a8dd6210889f51e696710b94471"> 
   <p>We need a MongoDB "find" query to locate a user document. To do that we need 2 JSON documents:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="99" id="99" data-hash="73c29560cc99667723bc396d17e55944"> c qyreu ouetdncm er njql sabde vn rvp aeluv vl rbo <code class="code">username</code> ifeld lx ogr esaadtab suncoemdt, nzp<br> </li> 
   <li class="listitem readable-text scrambled" refid="100" id="100" data-hash="b56aa3dd5a1bfb881129ade76da48426"> z odnmtuce rk ifypces rpk iefsdl rrcb dlosuh xu ndeetrur.<br> </li> 
  </ol> 
  <div class="readable-text scrambled" refid="101" id="101" data-hash="6535b3f6184fc1763fbd610e6823c739"> 
   <p>The code to perform such a query is in listing 10.14.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="102" id="102" data-hash="1634f65c720b4e685d146eb5a18e0099"> 
   <h5>Listing&nbsp;10.14.&nbsp;Fetching a user data in MongoDB</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">JsonObject query = new JsonObject()
  .put("username", username); #1

JsonObject fields = new JsonObject()
  .put("_id", 0)  #2
  .put("username", 1) #3
  .put("email", 1)
  .put("deviceId", 1)
  .put("city", 1)
  .put("makePublic", 1);

mongoClient
  .rxFindOne("user", query, fields) #4
  .toSingle()
  .subscribe(
    json -&gt; completeFetchRequest(ctx, json),
    err -&gt; handleFetchError(ctx, err));</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2Ugd2FudCB0byBtYXRjaCBleGFjdGx5IHRoZSB1c2VybmFtZS4KIzIgV2UgZG9u4oCZdCB3YW50IHRoZSBkb2N1bWVudCBpZGVudGlmaWVyLgojMyBXZSB3YW50IHRvIHJlcGVhdCB0aGUgdXNlcm5hbWUuCiM0IEZpbmQgb25lIGRvY3VtZW50Lg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="103" id="103" data-hash="f8c709fb762997f44eb1d68ff3060b73"> 
   <p>It is important to specify which fields should be part of the response, and be explicit about it. In our case we don’t want to reveal the document identifier so we set it to 0 in the fields document. We also explicitly list the fields that we want to be returned with 1 values. This also ensures that other fields like the password and salt values from the authentication do not get accidentally revealed.</p> 
  </div> 
  <div class="readable-text scrambled" refid="104" id="104" data-hash="6dc3f202eb6ed99dc4077ca2f6431568"> 
   <p>Listing 10.15 shows the 2 methods to complete the fetch request and HTTP response.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="105" id="105" data-hash="1908a0c607fe25700a32662e5d1279ee"> 
   <h5>Listing&nbsp;10.15.&nbsp;Completing a user fetch request</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private void completeFetchRequest(RoutingContext ctx, JsonObject json) {
  ctx.response()
    .putHeader("Content-Type", "application/json")
    .end(json.encode());  #1
}

private void handleFetchError(RoutingContext ctx, Throwable err) {
  if (err instanceof NoSuchElementException) {  #2
    ctx.fail(404);
  } else {
    fail500(ctx, err);
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgQ29tcGxldGUgc3VjY2Vzc2Z1bGx5IGJ5IGZvcndhcmRpbmcgdGhlIEpTT04gcmVzdWx0LgojMiBGYWlsIHdpdGggYSA0MDQgaWYgdGhlIHVzZXIgZG9lcyBub3QgZXhpc3QsIG9yIHdpdGggYSA1MDAgaWYgYSB0ZWNobmljYWwgZXJyb3Igd2FzIGVuY291bnRlcmVkLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="106" id="106" data-hash="c2979395f70ec25550a4527c79602def"> 
   <p>It is important to properly deal with the error cases and distinguish between a non-existing user and a technical error. Let us now see the case of updating a user.</p> 
  </div> 
  <div class="readable-text" refid="107" id="107" data-hash="64e0792e57cf1950d6700bbd020c3167"> 
   <h3 class="calibre29" id="heading_id_13"><a class="pcalibre pcalibre1" id="updating-a-user-data" shape="rect"></a>10.2.7 &nbsp;Updating a user data</h3> 
  </div> 
  <div class="readable-text scrambled" refid="108" id="108" data-hash="4472bf3972bb0f636a1f31a8dc3b0225"> 
   <p>Updating a user data shares similarities with fetching data, as we need 2 JSON documents again: one to match documents, and one to specify what fields need to be updated. Listing 10.16 shows the corresponding code.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="109" id="109" data-hash="d20086118c3115b91f5413c241915594"> 
   <h5>Listing&nbsp;10.16.&nbsp;Updating a user data with MongoDB</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">JsonObject query = new JsonObject().put("username", username);  #1
JsonObject updates = new JsonObject();
if (body.containsKey("city")) {                                 #2
  updates.put("city", body.getString("city"));
}
if (body.containsKey("email")) {
  updates.put("email", body.getString("email"));
}
if (body.containsKey("makePublic")) {
  updates.put("makePublic", body.getBoolean("makePublic"));
}

if (updates.isEmpty()) {                                        #3
  ctx.response().setStatusCode(200).end();
  return;
}

updates = new JsonObject().put("$set", updates);                #4
mongoClient
  .rxFindOneAndUpdate("user", query, updates)                   #5
  .ignoreElement()
  .subscribe(
    () -&gt; completeEmptySuccess(ctx),
    err -&gt; handleUpdateError(ctx, err));</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2Ugd2FudCB0byBtYXRjaCBieSB1c2VybmFtZS4KIzIgV2Ugc2VsZWN0aXZlbHkgY2hlY2sgZWFjaCBhbGxvd2VkIGZpZWxkIGZvciB1cGRhdGVzLgojMyBJZiBubyBhbGxvd2VkIGZpZWxkIHdhcyBzcGVjaWZpZWQsIHdlIGp1c3QgcXVpY2tseSByZXR1cm4uCiM0IFRoZSAkc2V0IG9wZXJhdG9yIGlzIHVzZWQgaW4gTW9uZ29EQiB0byB1cGRhdGUgZGF0YS4KIzUgV2Ugc2VhcmNoIGFuZCB1cGRhdGUgb25lIGRvY3VtZW50Lg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="110" id="110" data-hash="e46451dd7d82fcb02aeb5924d24c81cd"> 
   <p>Since the update request is a JSON document coming from a HTTP request, there is always a possibility of an external attack if we are not careful. We could indeed imagine that a malicious user crafts a JSON document in the request with updates to the password or username, and this is why we test for the presence of each allowed field in updates: city, email and makePublic. We then create a JSON document with updates just for these fields rather than reusing the JSON document received over HTTP, and make an update request to the Vert.x MongoDB client.</p> 
  </div> 
  <div class="readable-text scrambled" refid="111" id="111" data-hash="0b90269feba1339c9ed93a8386a00413"> 
   <p>We have just covered typical usage of MongoDB in Vert.x, as well as how to use it for authentication purposes. Let us now move on to PostgreSQL and the activity service.</p> 
  </div> 
  <div class="readable-text" refid="112" id="112" data-hash="93f6bf7a7bfe86734e7b5299c40d481e"> 
   <h2 class="calibre17" id="heading_id_14"><a class="pcalibre pcalibre1" id="activity-service-with-postgresql" shape="rect"></a>10.3 &nbsp;Activity service with PostgreSQL</h2> 
  </div> 
  <div class="readable-text scrambled" refid="113" id="113" data-hash="2106025b71757b0ee58c50a4bf8c91ad"> 
   <p>The activity service stores all steps updates as they are received from pedometers. It is a service that reacts to new step update events (to store data), and it can be queried by other services to get step counts for a given device on a given day, month or year.</p> 
  </div> 
  <div class="readable-text scrambled" refid="114" id="114" data-hash="3663f787fe6ac779b025e50ee98a8f40"> 
   <p>The activity services uses PostgreSQL to store activity data after device updates have been accepted by the ingestion service. PostgreSQL is well-suited because the SQL query language makes it easy to compute aggregates such as step counts for a device on a given month.</p> 
  </div> 
  <div class="readable-text" refid="115" id="115" data-hash="f4f1a8025bd80dfad0d6780bd0ef03ff"> 
   <p>The service is split into 2 independent verticles:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="116" id="116" data-hash="90c13818a6d3e27943cb012cbfcd26ae"> <code class="code">EventsVerticle</code> seitnsl tle iconignm tviacity pesdtau oteo Dlzoz nqc rnxd oetsrs shrs rjxn rgk bdeataas, hlwei<br> </li> 
   <li class="listitem readable-text scrambled" refid="117" id="117" data-hash="6c859ee79d00485ea00fde25a7013933"> <code class="code">ActivityApiVerticle</code> eexosps c HAAL CLJ tlv niruyqge ytviaict srqz.<br> </li> 
  </ol> 
  <div class="readable-text scrambled" refid="118" id="118" data-hash="761bc050ec753d4bf2c3b5e70c482861"> 
   <p>We could have put all the code on a single verticle, but this decoupling renders the code more manageable as each verticle has a well-defined purpose. EventsVerticle performs writes to the database, while ActivityApiVerticle performs the read operations.</p> 
  </div> 
  <div class="readable-text" refid="119" id="119" data-hash="ee1fe69a0bb3904a591d698ed33177de"> 
   <h3 class="calibre29" id="heading_id_15"><a class="pcalibre pcalibre1" id="data-model-2" shape="rect"></a>10.3.1 &nbsp;Data model</h3> 
  </div> 
  <div class="readable-text scrambled" refid="120" id="120" data-hash="98081b4860e41de3527bfa804718a594"> 
   <p>The data model is not terribly complex and fits in a single relation stepevent. The SQL instructions for creating the stepevent table are given in listing 10.17.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="121" id="121" data-hash="c0b1082e414a76bb4a1d3530742145ae"> 
   <h5>Listing&nbsp;10.17.&nbsp;SQL instruction for creating the stepevent table</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">CREATE TABLE IF NOT EXISTS stepevent
(
  device_id VARCHAR,
  device_sync BIGINT,
  sync_timestamp timestamptz, #1
  steps_count INTEGER,
  PRIMARY KEY (device_id, device_sync)  #2
);</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgQSB0aW1lc3RhbXAgd2l0aCBhIHRpbWV6b25lLgojMiBBIGNvbXBvc2l0ZSBwcmltYXJ5IGtleS4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="122" id="122" data-hash="7a1442745494f287aeac6d466175441f"> 
   <p>The primary key uniquely identifies an activity update based on a device identifier (device_id) and a synchronization counter from the device (device_sync). The timestamp of the event is recorded (sync_timestamp), and finally the number of steps is stored (steps_count).</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="123" id="123" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="124" id="124" data-hash="df46916a166d865e8e0a2e099d69b55a"> 
     <p>If you come from a background with a heavy usage of object-relational mappers (ORMs) then you may be surprised by the database schema above, and especially the fact that it uses a composite primary key rather than some auto-incremented number. You may want to first consider the proper design of your relational model with respect to normal forms, and only then see how to handle data in your code, be it with collections and/or objects that reflect the data.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="125" id="125" data-hash="3c66944a93be43cfe1ed482241175c33"> 
   <h3 class="calibre29" id="heading_id_16"><a class="pcalibre pcalibre1" id="opening-a-connection-pool" shape="rect"></a>10.3.2 &nbsp;Opening a connection pool</h3> 
  </div> 
  <div class="readable-text scrambled" refid="126" id="126" data-hash="85fcae0305df47d97d6509889ea1a385"> 
   <p>The vertx-pg-client module contains the PgPool interface that models a pool of connections to a PostgreSQL server, where each connection can be reused for subsequent queries. PgPool is your main access point in the client to perform SQL queries. Listing 10.18 shows how to create a PostgreSQL connection pool.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="127" id="127" data-hash="59dbb138c503c7ac4b892df7ab7237dd"> 
   <h5>Listing&nbsp;10.18.&nbsp;Creating a PostgreSQL connection pool</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">PgPool pgPool = PgPool.pool(vertx, PgConfig.pgConnectOpts(), new PoolOptions());  #1
// (...)

public static PgConnectOptions pgConnectOpts() {                                  #2
  return new PgConnectOptions()
    .setHost("localhost")
    .setDatabase("postgres")
    .setUser("postgres")
    .setPassword("vertx-in-action");
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgQ3JlYXRlIGEgY29ubmVjdGlvbiBwb29sLgojMiBDb25maWd1cmF0aW9uIGZvciB0aGUgY29ubmVjdGlvbi4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="128" id="128" data-hash="6aaff755cac3c8004e8dd4931d2fc465"> 
   <p>The pool creation requires a Vert.x context, a set of connection options such as the host, database and password, and pool options. The pool options can be tuned to set the maximum number of connections as well as the size of the waiting queue, but default values are fine here.</p> 
  </div> 
  <div class="readable-text scrambled" refid="129" id="129" data-hash="1f51add6ef052c209dd7f39fa2c5c6eb"> 
   <p>The pool object is then used to perform queries to the database as we are now going to see.</p> 
  </div> 
  <div class="readable-text" refid="130" id="130" data-hash="de885ef3952932ae9e6e54c94d404f4e"> 
   <h3 class="calibre29" id="heading_id_17"><a class="pcalibre pcalibre1" id="life-of-a-device-update-event" shape="rect"></a>10.3.3 &nbsp;Life of a device update event</h3> 
  </div> 
  <div class="readable-text scrambled" refid="131" id="131" data-hash="e9edc09997f47f5595a5795e00c554cb"> 
   <p>The EventsVerticle is in charge of listening to Kafka records on the incoming.steps topic where each record is an update received from a device through the ingestion service. For each record it must:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="132" id="132" data-hash="70bab502bae70743bddda5408e615ff2"> irtens rj knrj rog EeortgsSKZ aabtadse, rnyk<br> </li> 
   <li class="listitem readable-text scrambled" refid="133" id="133" data-hash="ccb5b49f1db14cb2c4eb6164554904b4"> reatenge ns tudpead wdrj bvr liyda etssp ntuco xtl rkp ecidve lv yor rocedr, gxnr<br> </li> 
   <li class="listitem readable-text scrambled" refid="134" id="134" data-hash="b2f3021c589359804949d03a4ac77774"> lphuisb rj az s wnk Oclzv cerord xr gor <code class="code">daily.step.updates</code> Qocsl opitc.<br> </li> 
  </ol> 
  <div class="readable-text" refid="135" id="135" data-hash="cde628c9db3596b83cb008573bb4beba"> 
   <p>This is illustrated in figure <a class="calibre8 pcalibre" href="/book/vertx-in-action/chapter-10/v-10/record-device-update" shape="rect" title="Figure 10.2. Steps to record a device update and produce an update event">10.2</a>.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="136" id="136" data-hash="8316282b1fe78a411583a848e6fcf287"> 
   <h5 id="record-device-update">Figure&nbsp;10.2.&nbsp;Steps to record a device update and produce an update event</h5> 
   <img alt="record device update" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/record-device-update.png" width="722" loading="lazy" height="456" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="137" id="137" data-hash="b0a4bd476894aa504e5600d01b2479b9"> 
   <p>These steps are modeled by the RxJava pipeline defined in listing 10.19.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="138" id="138" data-hash="bd2892240b601efae1a68e7c7cd9da56"> 
   <h5>Listing&nbsp;10.19.&nbsp;RxJava pipeline for processing updates in EventsVerticle</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">eventConsumer
  .subscribe("incoming.steps")  #1
  .toFlowable()
  .flatMap(this::insertRecord)  #2
  .flatMap(this::generateActivityUpdate)  #3
  .flatMap(this::commitKafkaConsumerOffset) #4
  .doOnError(err -&gt; logger.error("Woops", err))
  .retryWhen(this::retryLater)
  .subscribe();</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgU3Vic2NyaWJlIHRvIHRoZSBLYWZrYSB0b3BpYy4KIzIgSW5zZXJ0IGEgbmV3IHJlY29yZCBpbiB0aGUgZGF0YWJhc2UuCiMzIFF1ZXJ5IHRoZSBkYXRhYmFzZSB0byBwdWJsaXNoIGFub3RoZXIgcmVjb3JkLgojNCBDb21taXQgdGhlIHJlY29yZCB0byBLYWZrYS4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="139" id="139" data-hash="15c399a9db0d1f385a7bb6ffb095028f"> 
   <p>This RxJava pipeline is reminiscent of those we have seen earlier about the messaging and eventing stack, as we compose 3 asynchronous operations. This pipeline reads from Kafka, inserts database records (insertRecord), produces a query to write to Kafka (generateActivityUpdate) then commits it (commitKafkaConsumerOffset).</p> 
  </div> 
  <div class="readable-text" refid="140" id="140" data-hash="fd4248bc6a8db8296f8d0dd24b516a87"> 
   <h3 class="calibre29" id="heading_id_18"><a class="pcalibre pcalibre1" id="inserting-a-new-record" shape="rect"></a>10.3.4 &nbsp;Inserting a new record</h3> 
  </div> 
  <div class="readable-text scrambled" refid="141" id="141" data-hash="41890c0235739779d2187869fcc0ea44"> 
   <p>The SQL query to insert a record is given in listing 10.21.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="142" id="142" data-hash="a6f45a12b8045cbaaf74d53b1c02ee8e"> 
   <h5>Listing&nbsp;10.20.&nbsp;SQL query to insert step events</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">static String insertStepEvent() {
  return "INSERT INTO stepevent VALUES($1, $2, current_timestamp, $3)"; #1
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgJG4gaXMgdGhlIG4tdGggZW50cnkgaW4gdGhlIHZhbHVlcyB0dXBsZS4="></div> 
   </div> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="143" id="143" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="144" id="144" data-hash="642bda12b7d198b37e35dd02468ae0a9"> 
     <p>Vert.x does not prescribe any object-relational mapping tool. Doing plain SQL is actually a great option, but if you want to abstract your code from the particularities of databases and use an API to build your queries rather than using strings then I recommend looking at jOOQ [JOOQ]. You can even find a Vert.x / jOOQ integration module in the community!</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="145" id="145" data-hash="ea7af33ee097b3951b5547a6121704ec"> 
   <p>We use a class with static methods to give SQL queries as it is more convenient than plain string constants in our code. The query will be used as a prepared statement, where values prefixed by a $ symbol will be taken from a tuple of values. Since we use a prepared statement these values are safe from SQL injection attacks.</p> 
  </div> 
  <div class="readable-text scrambled" refid="146" id="146" data-hash="b92aef163ba88ed6444fb64a348415aa"> 
   <p>Method insertRecord is called for each new Kafka record, and the method body is given in listing 10.21.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="147" id="147" data-hash="0b75d5f57dbf41379e217a700bc4eb53"> 
   <h5>Listing&nbsp;10.21.&nbsp;Implementation of the insertRecord method</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">JsonObject data = record.value();             #1

Tuple values = Tuple.of(                      #2
  data.getString("deviceId"),
  data.getLong("deviceSync"),
  data.getInteger("stepsCount"));

return pgPool
  .rxPreparedQuery(insertStepEvent(), values) #3
  .map(rs -&gt; record)                          #4
  .onErrorReturn(err -&gt; {                     #5
    if (duplicateKeyInsert(err)) {
      return record;
    } else {
      throw new RuntimeException(err);
    }
  })
  .toFlowable();</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgSlNPTiBib2R5IGZyb20gdGhlIEthZmthIHJlY29yZC4KIzIgVHVwbGUgc3RydWN0dXJlLgojMyBJbnNlcnQgcmVxdWVzdC4KIzQgUmUtbWFwIHRoZSBLYWZrYSByZWNvcmQgZm9yIHRoZSBwcm9jZXNzaW5nIGluIHRoZSBnZW5lcmF0ZUFjdGl2aXR5VXBkYXRlIG1ldGhvZC4KIzUgSGFuZGxlIGR1cGxpY2F0ZSBpbnNlcnRzIGdyYWNlZnVsbHku"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="148" id="148" data-hash="453a4cd6c09e5e45888db9d52261d2e2"> 
   <p>We first extract the JSON body from the record, then prepare a tuple of values to pass as parameters to the SQL query of listing 10.20. The result of the query is a row set, but since this is not a SELECT query we do not care about the result. Instead we simply re-map the result with the original Kafka record value, so the generateActivityUpdate method can re-use it.</p> 
  </div> 
  <div class="readable-text scrambled" refid="149" id="149" data-hash="c1a0eacbf00511ea588bcc187d6852a6"> 
   <p>The onErrorReturn operator allows us to handle duplicate inserts gracefully. It is possible that after a service restart we end up replaying some Kafka events that we had already processed, so the INSERT queries will fail since that would result in entries with duplicate primary keys. Method duplicateKeyInsert from listing 10.22 shows how to distinguish between a duplicate key error and another technical error.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="150" id="150" data-hash="fe328f46d203984d163f7182f72866d6"> 
   <h5>Listing&nbsp;10.22.&nbsp;Detected a duplicate key error</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private boolean duplicateKeyInsert(Throwable err) {
  return (err instanceof PgException) &amp;&amp;
    "23505".equals(((PgException) err).getCode()); #1
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGVjaG5pY2FsIGNvZGUgZXJyb3IgZm9yIGEgZHVwbGljYXRlIGtleSBpbnNlcnRpb24gYXR0ZW1wdC4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="151" id="151" data-hash="d382d7320f1d3fdae508d831165ed9ba"> 
   <p>We again have to search for some technical error code in the exception message, and when it corresponds to a PostgreSQL duplicate key error then onErrorReturn puts the original Kafka record in the pipeline rather than let an error be propagated.</p> 
  </div> 
  <div class="readable-text" refid="152" id="152" data-hash="3557d72d166e808a823f77344b0a27be"> 
   <h3 class="calibre29" id="heading_id_19"><a class="pcalibre pcalibre1" id="generating-a-device-daily-activity-update" shape="rect"></a>10.3.5 &nbsp;Generating a device daily activity update</h3> 
  </div> 
  <div class="readable-text scrambled" refid="153" id="153" data-hash="db5b0c5d21ae680b99758f5ea25ce72b"> 
   <p>The next step in the RxJava processing pipeline after a record has been inserted is to query the database to get how many steps have been done on the current day. This is then used to prepare a new Kafka record and push it to the daily.step.updates Kafka topic.</p> 
  </div> 
  <div class="readable-text scrambled" refid="154" id="154" data-hash="47051068106e5444f1f036a67e043279"> 
   <p>The SQL query corresponding to that operation is given by the stepsCountForToday method from listing 10.23.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="155" id="155" data-hash="fdc6968f5e037e2271639baa83351cd7"> 
   <h5>Listing&nbsp;10.23.&nbsp;SQL query to get the steps count for a device on the current day</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">static String stepsCountForToday() {
  return "SELECT current_timestamp, coalesce(sum(steps_count), 0) FROM stepevent WHERE " +  #1
    "(device_id = $1) AND" +
    "(date_trunc('day', sync_timestamp) = date_trunc('day', current_timestamp))";           #2
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgU3RlcHMgY291bnQgd2lsbCBiZSAwIGlmIHRoZXJlIGFyZSBubyBtYXRjaGluZyBlbnRyaWVzLgojMiBNYXRjaCByZWNvcmRzIGZvciB0aGUgY3VycmVudCBkYXksIHRydW5jYXRpbmcgaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHMu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="156" id="156" data-hash="f7e460e2a8f0e838919522f0f0606050"> 
   <p>This request computes the sum (or zero) of the steps done on the current day for a give device identifier. Listing 10.24 provides the implementation of the generateActivityUpdate method, picking the original Kafka record forwarded by method insertRecord.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="157" id="157" data-hash="72208a614eb7bdbf4c0fa7c993f0a7ce"> 
   <h5>Listing&nbsp;10.24.&nbsp;Implementation of the generateActivityUpdate method</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">String deviceId = record.value().getString("deviceId");                                                 #1
LocalDateTime now = LocalDateTime.now();
String key = deviceId + ":" + now.getYear() + "-" + now.getMonth() + "-" + now.getDayOfMonth();         #2

return pgPool
  .rxPreparedQuery(stepsCountForToday(), Tuple.of(deviceId))                                            #3
  .map(rs -&gt; rs.iterator().next())                                                                      #4
  .map(row -&gt; new JsonObject()                                                                          #5
    .put("deviceId", deviceId)
    .put("timestamp", row.getTemporal(0).toString())
    .put("stepsCount", row.getLong(1)))
  .flatMap(json -&gt; updateProducer.rxSend(KafkaProducerRecord.create("daily.step.updates", key, json)))  #6
  .map(rs -&gt; record)
  .toFlowable();</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgRXh0cmFjdCB0aGUgZGV2aWNlIGlkZW50aWZpZXIgZnJvbSB0aGUgb3JpZ2luYWwgS2Fma2EgcmVjb3JkLgojMiBLZXkgZm9yIHRoZSBuZXcgS2Fma2EgcmVjb3JkLgojMyBQcmVwYXJlZCBzdGF0ZW1lbnQgd2l0aCBhIHR1cGxlIG9mIG9uZSB2YWx1ZS4KIzQgV2UgZXhwZWN0IGp1c3QgMSByb3cuCiM1IENyZWF0ZSBhIG5ldyBKc29uT2JqZWN0IG91ciBvZiB0aGUgcm93IHZhbHVlcy4KIzYgQ29tcG9zZSB0aGUgS2Fma2Egc2VuZCBvcGVyYXRpb24u"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="158" id="158" data-hash="18d059d993fa195f24e3c2cd02a7e0b9"> 
   <p>This code shows us how to manipulate rows following a SELECT query. The result of a query is RowSet, materialized here by the rs argument in the first map operator, and which can be iterated row-by-row. Since the query returns a single row, we can directly access the first and single row by calling next on the RowSet iterator. We then access the row elements by type and index to build a JsonObject that makes the Kafka record sent to the daily.step.updates topic.</p> 
  </div> 
  <div class="readable-text" refid="159" id="159" data-hash="ddc3daab3d8edda0dd66587218b5a8d5"> 
   <h3 class="calibre29" id="heading_id_20"><a class="pcalibre pcalibre1" id="activity-api-queries" shape="rect"></a>10.3.6 &nbsp;Activity API queries</h3> 
  </div> 
  <div class="readable-text scrambled" refid="160" id="160" data-hash="0e2a7bd9829514f6d81be8dd65e15d45"> 
   <p>The ActivityApiVerticle class exposes the HTTP API for the activity service, all routes lead to SQL queries. We are not going to show all of them so let us just focus on monthly steps for a device, handled through HTTP GET requests to /:deviceId/:year/:month. The SQL query is given in listing 10.25.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="161" id="161" data-hash="294f4c409e0b2051f9a30783ac03a192"> 
   <h5>Listing&nbsp;10.25.&nbsp;Monthly steps count SQL query</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">static String monthlyStepsCount() {
  return "SELECT sum(steps_count) FROM stepevent WHERE" +
    "(device_id = $1) AND" +
    "(date_trunc('month', sync_timestamp) = $2::timestamp)";  #1
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhlIHZhbHVlIG5lZWRzIHRvIGJlIGNvYWxlc2NlZCB0byBhIHRpbWVzdGFtcC4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="162" id="162" data-hash="1e9d79e4dcdef35a151683a7a1a84282"> 
   <p>The stepsOnMonth method is in listing 10.26 and performs the SQL query based on the year and month path parameters.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="163" id="163" data-hash="5571b5801cc21def473a64873a65d03d"> 
   <h5>Listing&nbsp;10.26.&nbsp;Handling monthly steps requests</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private void stepsOnMonth(RoutingContext ctx) {
  try {
    String deviceId = ctx.pathParam("deviceId");
    LocalDateTime dateTime = LocalDateTime.of(
      Integer.parseInt(ctx.pathParam("year")),
      Integer.parseInt(ctx.pathParam("month")),
      1, 0, 0);
    Tuple params = Tuple.of(deviceId, dateTime);          #1
    pgPool.rxPreparedQuery(SqlQueries.monthlyStepsCount(), params)
      .map(rs -&gt; rs.iterator().next())
      .subscribe(
        row -&gt; sendCount(ctx, row),                       #2
        err -&gt; handleError(ctx, err));                    #3
  } catch (DateTimeException | NumberFormatException e) { #4
    sendBadRequest(ctx);
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgUXVlcnkgYXJndW1lbnRzIHR1cGxlLgojMiBKU09OIHJlc3BvbnNlIGJhc2VkIG9uIHRoZSByb3cgZGF0YS4KIzMgU2VuZHMgYSBIVFRQIDQwMCBlcnJvci4KIzQgV2hlbiBhIFVSTCBwYXJhbWV0ZXIgaXMgbm90IGEgbnVtYmVyIG9yIGRvZXMgbm90IHJlc3VsdCBpbiBhIHZhbGlkIGRhdGUu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="164" id="164" data-hash="b5e7cdd09348b0c0d40728f388716803"> 
   <p>The query result is again a RowSet, and we know by the SQL query that only 1 row can be returned, so we use the map operator to extract it. The sendCount method sends the data as a JSON document, while the handleError method produces a HTTP 500 error. When a year or month URL parameter is not a number or does not result in a valid date then sendBadRequest produces a HTTP 400 to let the request know of a mistake.</p> 
  </div> 
  <div class="readable-text scrambled" refid="165" id="165" data-hash="9b0f6046482efa9b4ba899ed68999fd3"> 
   <p>It is now time to move on to integration testing strategies. This will also show you some other data client methods such as SQL batch queries when we will have to pre-populate a PostgreSQL database.</p> 
  </div> 
  <div class="readable-text" refid="166" id="166" data-hash="4e3b260f88c148544a24684e0adc3d9a"> 
   <h2 class="calibre17" id="heading_id_21"><a class="pcalibre pcalibre1" id="integration-tests" shape="rect"></a>10.4 &nbsp;Integration tests</h2> 
  </div> 
  <div class="readable-text scrambled" refid="167" id="167" data-hash="49a44300142b2cc9952e91280bc5ca01"> 
   <p>Testing the user profile service involves issuing HTTP requests to the corresponding API. The activity service has 2 facets: one that also involves the HTTP API, and one that involves crafting Kafka events and observing the effects in terms of persisted state and produced events.</p> 
  </div> 
  <div class="readable-text" refid="168" id="168" data-hash="95e819de7cf8e280efdf3e26dc88c15f"> 
   <h3 class="calibre29" id="heading_id_22"><a class="pcalibre pcalibre1" id="testing-the-user-profile-service" shape="rect"></a>10.4.1 &nbsp;Testing the user profile service</h3> 
  </div> 
  <div class="readable-text scrambled" refid="169" id="169" data-hash="a87869b8c3966c0c2355497d39004c55"> 
   <p>The user profile tests rely on issuing HTTP request that impact the service state and the database (e.g., creating a user) then issuing further HTTP requests to perform some assertions, as illustrated in figure 10.3.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="170" id="170" data-hash="3e32b29f258414745bfcc7e571898dcd"> 
   <h5 id="user-profile-test">Figure&nbsp;10.3.&nbsp;Testing the user profile service</h5> 
   <img alt="user profile test" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/user-profile-test.png" width="648" loading="lazy" height="327" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="171" id="171" data-hash="f4014897c0dee38da8d32aae02bff815"> 
   <p>The integration tests rely again on TestContainers as we need to have a MongoDB instance running. Once we have the container running, we need to prepare the MongoDB database to be in a clean state before we run any test. This is important to ensure that a test cannot be affected by data left over by a previous test execution. The setup method of class IntegrationTest performs the test preparation as found in listing 10.27.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="172" id="172" data-hash="2860bea76ce86c8adabb8df9298ed879"> 
   <h5>Listing&nbsp;10.27.&nbsp;User profile integration test setup</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">@BeforeEach
void setup(Vertx vertx, VertxTestContext testContext) {
  JsonObject mongoConfig = new JsonObject()
    .put("host", "localhost")
    .put("port", 27017)
    .put("db_name", "profiles");
  mongoClient = MongoClient.createShared(vertx, mongoConfig);

  mongoClient
    .rxCreateIndexWithOptions("user", new JsonObject().put("username", 1),    #1
      new IndexOptions().unique(true))
    .andThen(mongoClient.rxCreateIndexWithOptions("user",
      new JsonObject().put("deviceId", 1), new IndexOptions().unique(true)))  #2
    .andThen(dropAllUsers())                                                  #3
    .flatMapSingle(res -&gt; vertx.rxDeployVerticle(new UserProfileApiVerticle()))
    .subscribe(
      ok -&gt; testContext.completeNow(),
      testContext::failNow);
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgRW5zdXJlIHdlIGhhdmUgYW4gaW5kZXggb24gdXNlcm5hbWUuCiMyIEVuc3VyZSB3ZSBoYXZlIGFuIGluZGV4IG9uIGRldmljZUlkLgojMyBEcm9wIGFsbCB1c2Vycy4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="173" id="173" data-hash="a0f14b75de69e2e9811f803f9523e14a"> 
   <p>We first connect to the MongoDB database, then ensure we have 2 indexes for the username and deviceId fields. We then need to remove all existing documents from the profiles database (see listing 10.28), and deploy an instance of the UserProfileApiVerticle verticle before successfully completing the initialization phase.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="174" id="174" data-hash="9a4fbd7cebec6c7bc927fea883666b16"> 
   <h5>Listing&nbsp;10.28.&nbsp;Deleting all users in the MongoDB database</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private Maybe&lt;MongoClientDeleteResult&gt; dropAllUsers() {
  return mongoClient.rxRemoveDocuments("user", new JsonObject()); <a class="pcalibre pcalibre1" id="CO28-1" shape="rect"></a><span class="pcalibre1">#1</span>
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgTWF0Y2ggdW5jb25kaXRpb25hbGx5IHdpdGggYW4gZW1wdHkgSlNPTiBxdWVyeSBkb2N1bWVudC4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="175" id="175" data-hash="96ba63eed8c0abdcd168ef206ead858f"> 
   <p>The IntegrationTest class provides different test cases of operations that are expected to succeed as well as operations that are expected to fail. RestAssured is used to write the test specifications of the HTTP requests, like in listing 10.29.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="176" id="176" data-hash="65c5c0f8f97aa6b687569ad92de2cd00"> 
   <h5>Listing&nbsp;10.29.&nbsp;Test for authenticating a missing user</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">@Test
@DisplayName("Failing at authenticating an unknown user")
void authenticateMissingUser() {
  JsonObject request = new JsonObject() #1
    .put("username", "Bean")
    .put("password", "abc");

  with()
    .spec(requestSpecification)
    .contentType(ContentType.JSON)
    .body(request.encode())
    .post("/authenticate")
    .then()
    .assertThat()
    .statusCode(401);                   #2
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhpcyB1c2VyIGRvZXMgbm90IGV4aXN0LgojMiBXZSBleHBlY3QgYSBIVFRQIDQwMSBzdGF0dXMgY29kZS4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="177" id="177" data-hash="56fd30013ef39df3683664861d87033d"> 
   <p>The authenticateMissingUser method checks that authenticating against invalid credentials results in a HTTP 401 status code. Another example is the test of listing 10.30 where we check what happens when we attempt registering a user twice.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="178" id="178" data-hash="5b72c0acbdc21343b1fceca353a29599"> 
   <h5>Listing&nbsp;10.30.&nbsp;Test for registering a user twice</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">given()
  .spec(requestSpecification)
  .contentType(ContentType.JSON)
  .accept(ContentType.JSON)
  .body(basicUser().encode()) #1
  .when()
  .post("/register")
  .then()
  .assertThat()
  .statusCode(200);           #2

given()
  .spec(requestSpecification)
  .contentType(ContentType.JSON)
  .accept(ContentType.JSON)
  .body(basicUser().encode())
  .when()
  .post("/register")
  .then()
  .assertThat()
  .statusCode(409);           #3</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhpcyBtZXRob2QgcmV0dXJucyBhIHByZS1kZWZpbmVkIEpTT04gb2JqZWN0IGZvciBhIHVzZXIuCiMyIEZpcnN0IGF0dGVtcHQgaXMgb2suCiMzIFNlY29uZCBhdHRlbXB0IGlzIG5vdCBvayE="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="179" id="179" data-hash="175f0f9103c8207a0cf178695802cbdd"> 
   <p>Note that we could also peek into database and check the data that is being stored after each action. Since we need to cover all functional cases of the HTTP API it is more straightforward to focus on just the HTTP API in the integration tests. Now there are cases where an API on top of a database may not expose you to some important effects on the stored data, and in these cases you will need to connect to the database to do some further assertions.</p> 
  </div> 
  <div class="readable-text" refid="180" id="180" data-hash="05cf10a75a9650e507477fd179de5790"> 
   <h3 class="calibre29" id="heading_id_23"><a class="pcalibre pcalibre1" id="testing-the-activity-service-api" shape="rect"></a>10.4.2 &nbsp;Testing the activity service API</h3> 
  </div> 
  <div class="readable-text scrambled" refid="181" id="181" data-hash="67474b6fe643d8db6987de83ebb0193d"> 
   <p>The case of testing the activity service API is quite similar to that of the user profile service, except that we use PostgreSQL instead of MongoDB.</p> 
  </div> 
  <div class="readable-text scrambled" refid="182" id="182" data-hash="8024dd26b517fcf9dc974caafe293423"> 
   <p>We first need to ensure the data schema is defined as in listing 10.17. To do that the SQL script in init/postgres/setup.sql is run automatically when the PostgreSQL container starts. This works because the container image specifies that any SQL script found in /docker-entrypoint-initdb.d/ will be run when it starts, and the Docker Compose file that we use mounts init/postgres to /docker-entrypoint-initdb.d/ so the SQL file is available in the container.</p> 
  </div> 
  <div class="readable-text scrambled" refid="183" id="183" data-hash="ec15069d0f58a4862a51208890c6d756"> 
   <p>Once the database has been prepared with some pre-defined data, we issue HTTP requests to perform assertions as shown in figure 10.4.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="184" id="184" data-hash="3e40425ba16da1f3fc179cd529cdd7fc"> 
   <h5 id="activity-api-test">Figure&nbsp;10.4.&nbsp;Testing the activity service API</h5> 
   <img alt="activity api test" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/activity-api-test.png" width="552" loading="lazy" height="329" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="185" id="185" data-hash="795dbf2d08badae27a5e1b1ee8685bf7"> 
   <p>We again rely on TestContainers to start a PostgreSQL server for us, then rely on the test setup method to prepare the data as in listing 10.31.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="186" id="186" data-hash="b1fff2b293d80c8bc9dd695cff9e85ba"> 
   <h5>Listing&nbsp;10.31.&nbsp;Preparing the activity service API test</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">String insertQuery = "INSERT INTO stepevent VALUES($1, $2, $3::timestamp, $4)"; <a class="pcalibre pcalibre1" id="CO31-1" shape="rect"></a><span class="pcalibre1">#1</span>
LocalDateTime now = LocalDateTime.now();
List&lt;Tuple&gt; data = Arrays.asList( <a class="pcalibre pcalibre1" id="CO31-2" shape="rect"></a><span class="pcalibre1">#2</span>
  Tuple.of("123", 1, LocalDateTime.of(2019, 4, 1, 23, 0), 6541),
  Tuple.of("123", 2, LocalDateTime.of(2019, 5, 20, 10, 0), 200),
  Tuple.of("123", 3, LocalDateTime.of(2019, 5, 21, 10, 10), 100),
  Tuple.of("456", 1, LocalDateTime.of(2019, 5, 21, 10, 15), 123),
  Tuple.of("123", 4, LocalDateTime.of(2019, 5, 21, 11, 0), 320),
  Tuple.of("abc", 1, now.minus(1, ChronoUnit.HOURS), 1000),
  Tuple.of("def", 1, now.minus(2, ChronoUnit.HOURS), 100),
  Tuple.of("def", 2, now.minus(30, ChronoUnit.MINUTES), 900),
  Tuple.of("abc", 2, now, 1500)
);
PgPool pgPool = PgPool.pool(vertx, PgConfig.pgConnectOpts(), new PoolOptions());

pgPool.rxQuery("DELETE FROM stepevent")                                         <a class="pcalibre pcalibre1" id="CO31-3" shape="rect"></a><span class="pcalibre1">#3</span>
  .flatMap(rows -&gt; pgPool.rxPreparedBatch(insertQuery, data))                   <a class="pcalibre pcalibre1" id="CO31-4" shape="rect"></a><span class="pcalibre1">#4</span>
  .ignoreElement()
  .andThen(vertx.rxDeployVerticle(new ActivityApiVerticle()))                   <a class="pcalibre pcalibre1" id="CO31-5" shape="rect"></a><span class="pcalibre1">#5</span>
  .ignoreElement()
  .andThen(Completable.fromAction(pgPool::close))                               <a class="pcalibre pcalibre1" id="CO31-6" shape="rect"></a><span class="pcalibre1">#6</span>
  .subscribe(testContext::completeNow, testContext::failNow);</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgUXVlcnkgdG8gaW5zZXJ0IGRhdGEuCiMyIEEgc2V0IG9mIGVudHJpZXMgZm9yIHRoZSBkYXRhYmFzZS4KIzMgRW5zdXJlIG5vIGV2ZW50IGlzIGxlZnQuCiM0IEluc2VydCBvdXIgZGF0YS4KIzUgRGVwbG95IHRoZSBBUEkgdmVydGljbGUuCiM2IENsb3NlIHRoZSBjb25uZWN0aW9uIHBvb2wu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="187" id="187" data-hash="e7bff0cdb78ef66af629819f0eba5f3d"> 
   <p>Here we want a database with a data set that we control with activities for devices 123, 456, abc and def at various points in time. For instance device 123 recorded 320 steps on 2019/05/21 at 11:00, and that was the 4th time the device made a successful synchronization with the backend. We can then perform checks against the HTTP API like in listing 10.32 where we check the number of steps for device 123 in May 2019.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="188" id="188" data-hash="c4d4552fa9ed7a9bd7d6a106878b7405"> 
   <h5>Listing&nbsp;10.32.&nbsp;Checking steps for device 123 on a given month</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">JsonPath jsonPath = given()
  .spec(requestSpecification)
  .accept(ContentType.JSON)
  .get("/123/2019/05")                               #1
  .then()
  .assertThat()
  .statusCode(200)
  .extract()
  .jsonPath();

assertThat(jsonPath.getInt("count")).isEqualTo(620);  #2</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVVJMIG9mIHRoZSBxdWVyeS4KIzIgQ2hlY2sgdGhlIEpTT04gcmVzdWx0Lg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="189" id="189" data-hash="5e399a6a1b263f284d96d2dce433a2b7"> 
   <p>The activity HTTP API is the "read-only" part of the service, so let us now see the other part of the service.</p> 
  </div> 
  <div class="readable-text" refid="190" id="190" data-hash="0ae42883b361481107736dccbb52dee0"> 
   <h3 class="calibre29" id="heading_id_24"><a class="pcalibre pcalibre1" id="testing-the-activity-service-event-handling" shape="rect"></a>10.4.3 &nbsp;Testing the activity service event handling</h3> 
  </div> 
  <div class="readable-text scrambled" refid="191" id="191" data-hash="5a599037236e9d9a4841247a22006f90"> 
   <p>The technique to test the Kafka event processing part of the EventsVerticle is very similar to what we did in the previous chapter: we are going to send some Kafka records and then observe what Kafka records the service produces. By sending multiple step updates for a given device, we should observe that the service produces updates that accumulate the steps on the current day. Since the service both consumes and produces Kakfa records that reflect the current state of the database we won’t need to perform SQL queries, observing that correct Kafka record are being produced is sufficient. Figure 10.5 provides an overview of how the test is being made.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="192" id="192" data-hash="45789021db5af8598fa379d23a4d89aa"> 
   <h5 id="activity-event-test">Figure&nbsp;10.5.&nbsp;Testing the activity service event handling</h5> 
   <img alt="activity event test" class="calibre7" src="https://dpzbhybb2pdcj.cloudfront.net/ponge/v-10/Figures/activity-event-test.png" width="625" loading="lazy" height="308" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="193" id="193" data-hash="c26ce4158c0145a6d2b8b51f8e6ca254"> 
   <p>The integration test class (EventProcessingTest) again uses TestContainers to start the required services: PostgreSQL, Apache Kafka and Apache Zookeeper. Before any test is run, we must start from a clean state by using the test preparation code of listing 10.33.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="194" id="194" data-hash="86c180c3c1aab576c2dd4f2305c251ce"> 
   <h5>Listing&nbsp;10.33.&nbsp;Event processing integration tests preparation code</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">consumer = KafkaConsumer.create(vertx, KafkaConfig.consumer("activity-service-test-" + System.currentTimeMillis()));
producer = KafkaProducer.create(vertx, KafkaConfig.producer());
KafkaAdminClient adminClient = KafkaAdminClient.create(vertx, KafkaConfig.producer());
PgPool pgPool = PgPool.pool(vertx, PgConfig.pgConnectOpts(), new PoolOptions());

pgPool.rxQuery("DELETE FROM stepevent")           #1
  .flatMapCompletable(rs -&gt; adminClient.rxDeleteTopics(Arrays.asList("incoming.steps", "daily.step.updates")))  #2
  .andThen(Completable.fromAction(pgPool::close)) #3
  .onErrorComplete()
  .subscribe(
    testContext::completeNow,
    testContext::failNow);</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgRGVsZXRlIGRhdGEgZnJvbSB0aGUgZGF0YWJhc2UuCiMyIERlbGV0ZSBLYWZrYSB0b3BpY3MuCiMzIENsb3NlIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIHBvb2wu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="195" id="195" data-hash="c3d7de937a28a0093ebf25982cc242a5"> 
   <p>We need to ensure that the PostgreSQL database is empty, and that the Kafka topics that we use to receive and send events are deleted. We can then focus on the test method, where we will send 2 step updates for device 123. Before that we must first subscribe to the daily.step.updates Kafka topic where the EventsVerticle class will send Kafka records. Listing 10.34 shows the first part of the test case.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="196" id="196" data-hash="666552982f88c62be2dade11fb7ba210"> 
   <h5>Listing&nbsp;10.34.&nbsp;First part of the events verticle test case</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">consumer.subscribe("daily.step.updates")
  .toFlowable()
  .skip(1)                      #1
  .subscribe(record -&gt; {        #2
    JsonObject json = record.value();
    testContext.verify(() -&gt; {  #3
      assertThat(json.getString("deviceId")).isEqualTo("123");
      assertThat(json.containsKey("timestamp")).isTrue();
      assertThat(json.getInteger("stepsCount")).isEqualTo(250);
    });
    testContext.completeNow();
  }, testContext::failNow);</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgU2tpcCB0aGUgZmlyc3QgdXBkYXRlLgojMiBHZXQgdGhlIHNlY29uZCB1cGRhdGUuCiMzIFBlcmZvcm0gc29tZSBhc3NlcnRpb25zLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="197" id="197" data-hash="3b467a7e5f77579fc1e6473349ceb539"> 
   <p>Since we send 2 updates, we skip the emitted record and only perform assertions on the second one, as it should reflect the steps sum of the 2 updates. This code alone is waiting for events to be produced, so we now need to deploy the EventsVerticle and send the 2 updates as in listing 10.35.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="198" id="198" data-hash="6b7a320990e2bfd7ac4bff69cd7fd8f3"> 
   <h5>Listing&nbsp;10.35.&nbsp;Second part of the events verticle test case</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">vertx
  .rxDeployVerticle(new EventsVerticle()) #1
  .flatMap(id -&gt; {  #2
    JsonObject steps = new JsonObject()
      .put("deviceId", "123")
      .put("deviceSync", 1L)
      .put("stepsCount", 200);
    return producer.rxSend(KafkaProducerRecord.create("incoming.steps", "123", steps));
  })
  .flatMap(id -&gt; {  #3
    JsonObject steps = new JsonObject()
      .put("deviceId", "123")
      .put("deviceSync", 2L)
      .put("stepsCount", 50);
    return producer.rxSend(KafkaProducerRecord.create("incoming.steps", "123", steps));
  })
  .subscribe(ok -&gt; {
  }, testContext::failNow);</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgRGVwbG95IEV2ZW50c1ZlcnRpY2xlLgojMiBGaXJzdCB1cGRhdGUuCiMzIFNlY29uZCB1cGRhdGUu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="199" id="199" data-hash="92192a51be7b409731e159d7fd6ebe21"> 
   <p>The test completes as EventsVerticle properly sends correct updates to the daily.step.updates Kafka topic. We can again note how RxJava allows us to compose asynchronous operations in a declarative fashion, and ensure error processing is clearly identified. We have essentially 2 RxJava pipelines here and any error causes the test context to fail.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="200" id="200" data-hash="f35a087d0dc71beb3a7204d91c1c49e4"> 
     <h5>Note</h5> 
    </div> 
    <div class="readable-text scrambled" refid="201" id="201" data-hash="fb996c3fc673824a4934820b4ce11c24"> 
     <p>There is a tiny vulnerability window for this test to fail in case the first update is sent before midnight and the second right after midnight, in which case the second event will not be a sum of the steps in the 2 events. This is very unlikely to happen since the 2 events will be emitted a few milliseconds appart, but still, it could happen!</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="202" id="202" data-hash="1b84eb5b274e24703b3d1a202791a32a"> 
   <p>Speaking of event streams, the next chapter will focus on the topic of advanced event processing services with Vert.x.</p> 
  </div> 
  <div class="readable-text" refid="203" id="203" data-hash="656270afd35b00d85d212654f00a399b"> 
   <h2 class="calibre17" id="heading_id_25"><a class="pcalibre pcalibre1" id="summary" shape="rect"></a>10.5 &nbsp;Summary</h2> 
  </div> 
  <ul class="itemizedlist"> 
   <li class="listitem readable-text" refid="204" id="204" data-hash="7b3b68752677c417313974ac4daee08f"> The Vert.x MongoDB client allows to store and query documents.<br> </li> 
   <li class="listitem readable-text" refid="205" id="205" data-hash="95eddfe04b8f45b5e891bf0950bccb33"> Vert.x can also use MongoDB to perform authentication and safely store user credentials, roles and permissions.<br> </li> 
   <li class="listitem readable-text" refid="206" id="206" data-hash="ec9d3f3a8ee952ad86d044fe8a60aa87"> Vert.x offers an efficient reactive driver for PostgreSQL.<br> </li> 
   <li class="listitem readable-text" refid="207" id="207" data-hash="523d676855a3fb3acd7b4edca6ce6ac7"> You do not always need an object-relational mapper, working directly with SQL and relational data can actually be simple and efficient.<br> </li> 
   <li class="listitem readable-text" refid="208" id="208" data-hash="fa91860b8c242caa4f696d81ed3aed5c"> It is important to ensure clean state in databases before executing integration tests.<br> </li> 
  </ul> 
  <div class="readable-text" refid="209" id="209" data-hash="99af39588bcbc7ab0289cf597b5f113a"> 
   <h2 class="calibre17" id="heading_id_26"><a class="pcalibre pcalibre1" id="references" shape="rect"></a>10.6 &nbsp;References</h2> 
  </div> 
  <div class="bibliodiv"> 
   <div class="bibliomixed"> <a class="pcalibre" id="d5e7865" shape="rect"></a> 
    <div class="readable-text" refid="210" id="210" data-hash="caed95824e18ca36162cd5b68604ae69"> 
     <p><span class="bibliomisc"><a class="pcalibre" id="OWASP" shape="rect"></a>[<b class="calibre31">OWASP</b>] The Open Web Application Security Project (OWASP). OWASP Validation Regex Repository. Retrieved November 2019. <a class="pcalibre3 pcalibre" href="https://www.owasp.org/index.php/OWASP_Validation_Regex_Repository" shape="rect">www.owasp.org/index.php/OWASP_Validation_Regex_Repository</a></span></p> 
    </div> 
   </div> 
   <div class="bibliomixed"> <a class="pcalibre" id="d5e7869" shape="rect"></a> 
    <div class="readable-text" refid="211" id="211" data-hash="9d8fe04c90332fe5df899eb2ade551d0"> 
     <p><span class="bibliomisc"><a class="pcalibre" id="Neward06" shape="rect"></a>[<b class="calibre31">Neward06</b>] Ted Neward. The Vietnam of Computer Science. Retrieved November 2019. <a class="pcalibre3 pcalibre" href="http://blogs.tedneward.com/post/the-vietnam-of-computer-science/" shape="rect">blogs.tedneward.com/post/the-vietnam-of-computer-science/</a></span></p> 
    </div> 
   </div> 
   <div class="bibliomixed"> <a class="pcalibre" id="d5e7873" shape="rect"></a> 
    <div class="readable-text" refid="212" id="212" data-hash="2766023883fd3afa904d68bdf6866532"> 
     <p><span class="bibliomisc"><a class="pcalibre" id="DTO" shape="rect"></a>[<b class="calibre31">DTO</b>] Martin Fowler. Data Transfer Object. Retrieved November 2019. <a class="pcalibre3 pcalibre" href="https://martinfowler.com/eaaCatalog/dataTransferObject.html" shape="rect">martinfowler.com/eaaCatalog/dataTransferObject.html</a></span></p> 
    </div> 
   </div> 
   <div class="bibliomixed"> <a class="pcalibre" id="d5e7877" shape="rect"></a> 
    <div class="readable-text" refid="213" id="213" data-hash="c6bccbb84676b6cd4490b17e09af1548"> 
     <p><span class="bibliomisc"><a class="pcalibre" id="JOOQ" shape="rect"></a>[<b class="calibre31">JOOQ</b>] Data Geekery GmbH. jOOQ. Retrieved November 2019. <a class="pcalibre3 pcalibre" href="https://www.jooq.org/" shape="rect">www.jooq.org/</a></span></p> 
    </div> 
   </div> 
  </div>
 </body>
</html>