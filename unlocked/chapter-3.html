<html>
 <head>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/default.min.css"> 
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
  <script src="highlight.js"></script>
 </head>
 <body>
  <div class="readable-text" refid="1" id="1" data-hash="0b6792a51b06d737f1560050900183c9"> 
   <h1 class="chaptertitle" id="heading_id_23">3 <a class="pcalibre pcalibre1" id="event-bus-the-backbone-of-a-vert-x-application" shape="rect"></a>Event-bus: the backbone of a Vert.x application</h1> 
  </div> 
  <div class=" introduction-summary"> 
   <h3 class="intro-header">This chapter covers:</h3> 
   <ul> 
    <li class=" readable-text" refid="2" id="2" data-hash="53b65f1f1715407d073dffce45b2dcf8"> What is the event-bus,<br> </li> 
    <li class=" readable-text" refid="3" id="3" data-hash="51fce5b3228995d8e66160c1b8bb71d3"> How to have point-to-point, request-reply and publish / subscribe communications over the event-bus,<br> </li> 
    <li class=" readable-text" refid="4" id="4" data-hash="3db0a1d244195956e7e2c51590a4b5d1"> The distributed event-bus for verticle-to-verticle communications across the network.<br> </li> 
   </ul> 
  </div> 
  <div class="readable-text" refid="5" id="5" data-hash="9355e75665ccb930556cae7730d8f483"> 
   <p>The previous chapter introduced <em class="calibre10">verticles</em>. A Vert.x application is made of 1 or more verticles, and each verticle forms a unit for processing asynchronous events. It is common to specialize verticles by functional and technical concerns, such as a verticle for exposing a HTTP API and a verticle for dealing with a data store. This design also encourages deploying several instances of a given verticle for scalability purposes.</p> 
  </div> 
  <div class="readable-text" refid="6" id="6" data-hash="ca9c5aaec693011ba2f5ee35fbdb1ef2"> 
   <p>Now what we did <em class="calibre10">not</em> cover is how verticles can communicate with each other. Back to the previous example a HTTP API verticle needs to <em class="calibre10">talk</em> to the data store verticle if the larger Vert.x application is doing anything useful.</p> 
  </div> 
  <div class="readable-text" refid="7" id="7" data-hash="7a274d2b7739451fdead4f3e69bed47d"> 
   <p>Connecting verticles and making sure they can cooperate is exactly the role of the event-bus.</p> 
  </div> 
  <div class="readable-text" refid="8" id="8" data-hash="eabb132b8fe23650dfc6e7026e443e01"> 
   <h2 class="calibre17" id="heading_id_3"><a class="pcalibre pcalibre1" id="what-is-the-event-bus" shape="rect"></a>3.1 &nbsp;What is the event-bus?</h2> 
  </div> 
  <div class="readable-text" refid="9" id="9" data-hash="a16d39eb981f09e30cbea450cf74c47c"> 
   <p>The event-bus is a mean for sending and receiving messages in an asynchronous fashion. Messages are being sent (and retrieved) from <em class="calibre10">destinations</em>. A destination is simply a free-form string, such as <code class="code">incoming.purchase.orders</code> or <code class="code">incoming-purchase-orders</code>, although the former form with dots is preferred.</p> 
  </div> 
  <div class="readable-text scrambled" refid="10" id="10" data-hash="2252508174dd5f1786570f74ae1bfa80"> 
   <p>Messages have a body, optional headers for storing meta-data, and an optional expiration delay after which they will be discarded if they haven’t been processed yet. Message bodies are commonly encoded using the Vert.x JSON representation. The advantage of using JSON is that it is a serialization format that can be easily transported over the network, and all programming languages understand it. It is also possible to use Java primitive and string types, especially as JVM languages that may be used for writing verticles have direct bindings for them. Last but not least: it is possible to register custom encoder / decoders (codec) to support more specialized forms of message body serialization. For instance you could write a codec for converting Java objects to a binary encoding of your own. This is however rarely useful to do so, and in practice JSON and string data cover most Vert.x applications needs.</p> 
  </div> 
  <div class="readable-text scrambled" refid="11" id="11" data-hash="38eb2ef3384fb20fa2dbe12948fb25df"> 
   <p>The event-bus allows for decoupling between verticles: there is no need for one verticle to access another verticle class, as all that is needed is to agree on destination names and data representation. Another benefit is that since Vert.x is polyglot, the event-bus allows verticles written in different languages to communicate with each other without requiring any complex language interoperability layer, be it to for communications inside the same JVM process or across the network.</p> 
  </div> 
  <div class="readable-text scrambled" refid="12" id="12" data-hash="adc02f70bbbfa763ea8e8c701c17fde3"> 
   <p>An interesting property of the event-bus is that it can be extended outside of the application process. We will see in this chapter that the event-bus also works across distributed members of a cluster. Later in this book we will see how to extend the event-bus to embedded or external message brokers, to remote clients and also to JavaScript applications running in a web browser.</p> 
  </div> 
  <div class="readable-text" refid="13" id="13" data-hash="6c80d31ad91fcd3e4eb7e14d0b9763f8"> 
   <p>Communications over the event-bus happen following 3 patterns:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="14" id="14" data-hash="f868dd75dc959895e91df12c9c18bdad"> tnopi-xr-ontpi eiaggmnss,<br> </li> 
   <li class="listitem readable-text scrambled" refid="15" id="15" data-hash="c78b59f5ddaa072489e0a8455be2cf4d"> reestqu-yplre msgsaigne,<br> </li> 
   <li class="listitem readable-text scrambled" refid="16" id="16" data-hash="5e8aa51f67aea46b74b876d16e468189"> usbplhi / iursbbces enmsggisa.<br> </li> 
  </ol> 
  <div class="readable-text" refid="17" id="17" data-hash="b752be40bacc28d9ad245f0f0c167b77"> 
   <h3 class="calibre29" id="heading_id_4"><a class="pcalibre pcalibre1" id="so-is-the-event-bus-just-another-message-broker" shape="rect"></a>3.1.1 &nbsp;So is the event-bus just another message broker?</h3> 
  </div> 
  <div class="readable-text scrambled" refid="18" id="18" data-hash="f84eeacffc974ab76c0a5c4ed41604f3"> 
   <p>Readers familiar with message-oriented middleware will have spotted the obvious resemblance between the event-bus and a message broker. After all the event-bus exhibits familiar messaging patterns, such as the publish / subscribe pattern which is popular for integrating distributed and heterogeneous applications.</p> 
  </div> 
  <div class="readable-text scrambled" refid="19" id="19" data-hash="83cec74db28a071eafc3dd226dffa589"> 
   <p>The short answer is that no, the Vert.x event-bus is not yet another alternative to Apache ActiveMQ, RabbitMQ, ZeroMQ or Apache Kafka.</p> 
  </div> 
  <div class="readable-text scrambled" refid="20" id="20" data-hash="27b5c8e232e659599d6a7ca552d55513"> 
   <p>The longer explanation is that it is an event bus for verticle-to-verticle communications inside an application, not a message bus for application-to-application communications. As we will see later in this book Vert.x integrates with message brokers, but the event-bus is no replacement for this type of middleware. Especially, the event-bus does not:</p> 
  </div> 
  <ul class="itemizedlist"> 
   <li class="listitem readable-text scrambled" refid="21" id="21" data-hash="319d5d99db5120729c58b69622116631"> tspurpo gssamee nmnwkadglteoesc, tk<br> </li> 
   <li class="listitem readable-text scrambled" refid="22" id="22" data-hash="e341bf1c1309942a1dcee5ded3e94a19"> souprpt semgeas irtioisepr, et<br> </li> 
   <li class="listitem readable-text scrambled" refid="23" id="23" data-hash="6bb10c60fd11d2527384f3aefbfd4ad9"> portpsu meegass uiyadribtl rv cverroe xmlt rceshas, et<br> </li> 
   <li class="listitem readable-text scrambled" refid="24" id="24" data-hash="720ee88242133d842b2e41cc0b98203d"> ipdervo nugotir ulsre, te<br> </li> 
   <li class="listitem readable-text scrambled" refid="25" id="25" data-hash="a92def55479b89a78b1a880ae810b336"> odpreiv omainfntsotrar esrlu (amhecs datiaatpon, tratecs / artheg, svr).<br> </li> 
  </ul> 
  <div class="readable-text scrambled" refid="26" id="26" data-hash="3f288f8844a1708b1e17e44708cf11cd"> 
   <p>The event-bus simply carries volatile events that are being processed asynchronously by verticles. Not all events are created equal, and some may be lost, some may not. In our quest for writing reactive applications, we will see where to use data replication and/or message brokers such as Apache Kafka [KafkaInAction] in combination with the event-bus.</p> 
  </div> 
  <div class="readable-text scrambled" refid="27" id="27" data-hash="649bf540eecc1dee2caef34626bbffc1"> 
   <p>The event-bus is a simple and fast event conveyor, and we can take advantage of it for most verticle-to-verticle interactions while delegating to more costly middleware for the events that cannot be lost.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="28" id="28" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="29" id="29" data-hash="85be467c645dc625227b7edaccff480c"> 
     <p>Readers familiar with messaging patterns may read the next 3 subsections more quickly or even skip them.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="30" id="30" data-hash="93d747930a56ee52f9dfa767171cd54d"> 
   <h3 class="calibre29" id="heading_id_5"><a class="pcalibre pcalibre1" id="point-to-point-messaging" shape="rect"></a>3.1.2 &nbsp;Point-to-point messaging</h3> 
  </div> 
  <div class="browsable-container figure-container" refid="31" id="31" data-hash="ed568e7389f831276fddeb8fcc0bbbf0"> 
   <h5 id="eb-ptop">Figure&nbsp;3.1.&nbsp;Point-to-point messaging over the event-bus</h5> 
   <img alt="event bus ptop" class="calibre7" src="ponge/v-10/Figures/event-bus-ptop.png" width="1036" loading="lazy" height="346" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="32" id="32" data-hash="12d8293544e71000d750fba9c1c05be5"> 
   <p>Messages are being sent by producers to some destinations such as a.b.c in figure 3.1. Destination names are free-form strings, but the convention in the Vert.x community is to use separating dots. For example we could use datastore.new-purchase-orders to send new purchase orders for being stored in a database.</p> 
  </div> 
  <div class="readable-text scrambled" refid="33" id="33" data-hash="1ec84999f246b52b9fcf0337b365461d"> 
   <p>With point-to-point messaging, one of the possibly multiple consumers picks a message and processes it. The figure shows this with messages M1, M2 and M3.</p> 
  </div> 
  <div class="readable-text scrambled" refid="34" id="34" data-hash="fca39d0b1559f80e3295631c6f2fabaf"> 
   <p>Messages are being distributed in a round-robin fashion among the consumers so they split message processing in equal proportions. This is why in figure 3.1 the first consumer processes M1 and M3, while the second consumer processes M2. Note that there is no fairness mechanism to distribute less messages to an overloaded consumer.</p> 
  </div> 
  <div class="readable-text" refid="35" id="35" data-hash="d1d548acc081f70c92ef25726f9125b1"> 
   <h3 class="calibre29" id="heading_id_6"><a class="pcalibre pcalibre1" id="request-reply-messaging" shape="rect"></a>3.1.3 &nbsp;Request-reply messaging</h3> 
  </div> 
  <div class="browsable-container figure-container" refid="36" id="36" data-hash="9969785e1f72dc6ee365de06b49eeee4"> 
   <h5 id="eb-reqresp">Figure&nbsp;3.2.&nbsp;Request-reply messaging over the event-bus</h5> 
   <img alt="event bus reqresp" class="calibre7" src="ponge/v-10/Figures/event-bus-reqresp.png" width="1055" loading="lazy" height="255" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="37" id="37" data-hash="15cfaa0f47cb17b8634143b71f3ec114"> 
   <p>In Vert.x this communication pattern is a variation of point-to-point messaging. When a message is being sent in point-to-point messaging, it is possible to register a reply handler. In this case the event-bus generates a temporary destination name dedicated solely to the communications between the request message producer expecting a reply, and the consumer that will eventually receive and process the message.</p> 
  </div> 
  <div class="readable-text scrambled" refid="38" id="38" data-hash="e52927971c7d6888198ed5e446506442"> 
   <p>This messaging pattern works well for mimicking remote procedure calls, but with the response being sent in an asynchronous fashion so there is no need to keep waiting until it comes back. For example a HTTP API verticle can send a request to a data store verticle to fetch some data, and the data store verticle eventually gives back a reply message.</p> 
  </div> 
  <div class="readable-text scrambled" refid="39" id="39" data-hash="e2bd930c39f0009912f7f59406c0baec"> 
   <p>This pattern is illustrated in figure 3.2. A reply destination is generated by the event-bus and attached to the message before it reaches a consumer when a message expects a reply. You can inspect the reply destination name through the event-bus message API if you want, but you will rarely need to know what the destination is since you will simply call a reply method on the message object. Of course a message consumer needs to be programmed to provide a reply when this pattern is being used.</p> 
  </div> 
  <div class="readable-text" refid="40" id="40" data-hash="64d86e555ed9fbdc19eb557c4bd53a6f"> 
   <h3 class="calibre29" id="heading_id_7"><a class="pcalibre pcalibre1" id="publish-subscribe-messaging" shape="rect"></a>3.1.4 &nbsp;Publish / subscribe messaging</h3> 
  </div> 
  <div class="browsable-container figure-container" refid="41" id="41" data-hash="5b23f7f4faf27567f2acb2b812307700"> 
   <h5 id="eb-pubsub">Figure&nbsp;3.3.&nbsp;Publish / subscribe messaging over the event-bus</h5> 
   <img alt="event bus pubsub" class="calibre7" src="ponge/v-10/Figures/event-bus-pubsub.png" width="1036" loading="lazy" height="341" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="42" id="42" data-hash="b0f9ed0b0e70d67f3077a1862a596641"> 
   <p>In publish / subscribe communications there is even more decoupling between producers and consumers. When a message is being sent to a destination, all subscribers receive it, as illustrated per figure 3.3. Messages M1, M2 and M3 are each sent by a different producer, and all subscribers receive the messages unlike in the case of point-to-point messaging (see figure 3.1). It is not possible to specify reply handlers for publish / subscribe communications on the event-bus.</p> 
  </div> 
  <div class="readable-text scrambled" refid="43" id="43" data-hash="d72e9705db556b7b49fee35b9315e7af"> 
   <p>Publish / subscribe is useful when it is not sure à-priori how many verticles and handlers will be interested in a particular event. If you need message consumers to get back to the entity that sent the event then go for request-reply. Otherwise opting for point-to-point versus publish / subscribe is a matter of functional requirements, mostly wether all consumers shall process an event or whether just one consumer should.</p> 
  </div> 
  <div class="readable-text" refid="44" id="44" data-hash="9b178023346076776b4c22180a2cf843"> 
   <h2 class="calibre17" id="heading_id_8"><a class="pcalibre pcalibre1" id="the-event-bus-through-an-example" shape="rect"></a>3.2 &nbsp;The event-bus through an example</h2> 
  </div> 
  <div class="readable-text scrambled" refid="45" id="45" data-hash="fc2780e5d5029c11709c5cb25e862750"> 
   <p>Let us now put the event-bus to use and see how we can articulate communications between independent verticles.</p> 
  </div> 
  <div class="readable-text scrambled" refid="46" id="46" data-hash="6d75c62d904df2458b7dec1d883acd34"> 
   <p>The example that we are going to use is based around several temperature sensors. Of course we are not going to use any hardware and instead we will let temperatures evolve using pseudo-random numbers. We will also expose a simple web interface where temperatures and their average will be updated live.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="47" id="47" data-hash="1b9fb32fb961b426fbf134220782236c"> 
   <h5 id="webapp">Figure&nbsp;3.4.&nbsp;Screenshot of the web interface</h5> 
   <img alt="webapp" class="calibre7" src="ponge/v-10/Figures/webapp.png" width="1052" loading="lazy" height="608" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="48" id="48" data-hash="080fe092bde4274659235eeeb2e40221"> 
   <p>A screenshot of the web interface is in figure 3.4. Here it follows the temperatures of 4 sensors, and keeps their average up-to-date. The communications between the web interface and the server will happen using server-sent events, a simple yet effective protocol supported by most web browsers [SSE].</p> 
  </div> 
  <div class="browsable-container figure-container" refid="49" id="49" data-hash="2a7dbe822d79b8c17c1a12495bb99996"> 
   <h5 id="usecase">Figure&nbsp;3.5.&nbsp;Overview of the example architecture</h5> 
   <img alt="event bus usecase" class="calibre7" src="ponge/v-10/Figures/event-bus-usecase.png" width="1048" loading="lazy" height="752" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="50" id="50" data-hash="c765ac35c5c8226815dac4fd54ff501b"> 
   <p>Figure 3.5 gives an overview of the application architecture. The figure has 2 concurrent event communications annotated with ordering sequences [1, 2, 3] (a temperature update is being sent) and [a, b, c, d] (a temperature average computation is being requested).</p> 
  </div> 
  <div class="readable-text" refid="51" id="51" data-hash="29e8907e70efb0a90f9b1cbbe27d2ce9"> 
   <p>The application is structured around 4 verticles.</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="52" id="52" data-hash="a514995521bf7c643e419459376d8ff4"> <code class="code">HeatSensor</code> sngaeeetr rmtpaeurete emauesrs zr nen-fxied tsrae, gcn sbiuehpsl mvrg kr besirucrbss xl rpo <code class="code">sensor.updates</code> asendonitit. Zasq icvrelte syc s quienu rensos iietdirefn.<br> </li> 
   <li class="listitem readable-text scrambled" refid="53" id="53" data-hash="67bb0979f3abd286bc312b785b13edbf"> <code class="code">Listener</code> roismton nwv reterumapet reusasme, ncp dzfv xmrp unsig SEE4I.<br> </li> 
   <li class="listitem readable-text scrambled" refid="54" id="54" data-hash="661838a79d82b7c600098db8d1a4a7e1"> <code class="code">SensorData</code> ekpes c rcdeor lk qor tsalte dseerobv svulea lvt zkzb snrsoe. Jr kfcz uspoptsr seqetur-rnsepoes muscamoioncitn: nigndes z amsseeg xr <code class="code">sensor.average</code> rstiergg c nctmauotipo lk ryx veegaar aebsd kn qrv etstal rszq, hnz ord serutl cj rckn poza zc z ensorpse.<br> </li> 
   <li class="listitem readable-text scrambled" refid="55" id="55" data-hash="ec639619a197e8297d4fa77938719136"> <code class="code">HttpServer</code> spexsoe rpo HRBE rvrese nuz essevr vry wvu taernfiec. Jr shupse nwv veslua rx zjr cnsitle enrehvwe s onw aprteeetmru mearsteunem zuc gnkv edvsebor, bsn jr alipydeilrco zcco tlv ryv rcnuret geaaevr, rvgn tapudse zff rvq otedcencn insclte.<br> </li> 
  </ol> 
  <div class="readable-text" refid="56" id="56" data-hash="3537911abcfce79d754b3eb11362f882"> 
   <h3 class="calibre29" id="heading_id_9"><a class="pcalibre pcalibre1" id="heat-sensor-verticle" shape="rect"></a>3.2.1 &nbsp;Heat sensor verticle</h3> 
  </div> 
  <div class=" browsable-container listing-container" refid="57" id="57" data-hash="2be6b4885b36c63653ebc6b52569db7f"> 
   <h5>Listing&nbsp;3.1.&nbsp;Heat sensor verticle implementation</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class HeatSensor extends AbstractVerticle {
  private final Random random = new Random();
  private final String id = UUID.randomUUID().toString();   #1
  private double temp = 21.0;

  @Override
  public void start() {
    scheduleNextUpdate();
  }

  private void scheduleNextUpdate() {
    vertx.setTimer(random.nextInt(5000) + 1000, this::update);  #2
  }

  private void update(long tid) {
    temp = temp + (delta() / 10);
    JsonObject payload = new JsonObject()
      .put("id", id)
      .put("temp", temp);
    vertx.eventBus().publish("sensor.updates", payload);    #3
    scheduleNextUpdate();   #4
  }

  private double delta() {  #5
    if (random.nextInt() &gt; 0) {
      return random.nextGaussian();
    } else {
      return -random.nextGaussian();
    }
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhlIHNlbnNvciBpZCBpcyBnZW5lcmF0ZWQgdXNpbmcgYSBVVUlELgojMiBVcGRhdGVzIGFyZSBzY2hlZHVsZWQgdXNpbmcgYSByYW5kb20gZGVsYXkgYmV0d2VlbiAxIGFuZCA2IHNlY29uZHMuCiMzIHB1Ymxpc2ggc2VuZHMgYSBtZXNzYWdlIHRvIHN1YnNjcmliZXJzLgojNCBXZSBzY2hlZHVsZSB0aGUgbmV4dCB1cGRhdGUuCiM1IFRoaXMgY29tcHV0ZXMgYSByYW5kb20gcG9zaXRpdmUgb3IgbmVnYXRpdmUgdmFsdWUgdG8gc2xpZ2h0bHkgbW9kaWZ5IHRoZSBjdXJyZW50IHRlbXBlcmF0dXJlLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="58" id="58" data-hash="fc92c4cae5d254c6b8b35db4e95bf5c7"> 
   <p>Listing 3.1 provides the implementation of the HeatSensor verticle class. It does not use any realistic temperature model but instead uses random increments or decrements. Hence if you run it long enough it may report absurd values, but this is not very important in our journey through reactive applications.</p> 
  </div> 
  <div class="readable-text scrambled" refid="59" id="59" data-hash="c6bca077bacd49e2520717fcb349ed2a"> 
   <p>The event-bus is accessed through the Vertx context and the eventBus() method. Since this verticle does not know what published values will be used for, it uses the publish method to send to subscribers on the sensor.updates destination. We also use JSON to encode data, which is idiomatic with Vert.x.</p> 
  </div> 
  <div class="readable-text" refid="60" id="60" data-hash="66bc91bcb4504d939889efdf23af2f2d"> 
   <p>Let us now see a verticle that consumes temperature updates.</p> 
  </div> 
  <div class="readable-text" refid="61" id="61" data-hash="f506a72b483bba16378692736f68a88f"> 
   <h3 class="calibre29" id="heading_id_10"><a class="pcalibre pcalibre1" id="listener-verticle" shape="rect"></a>3.2.2 &nbsp;&nbsp;Listener verticle</h3> 
  </div> 
  <div class=" browsable-container listing-container" refid="62" id="62" data-hash="ad50ed60456ed70a093e9f94ba6239ae"> 
   <h5>Listing&nbsp;3.2.&nbsp;Listener verticle implementation</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class Listener extends AbstractVerticle {
  private final Logger logger = LoggerFactory.getLogger(Listener.class);
  private final DecimalFormat format = new DecimalFormat("#.##");   <a class="pcalibre pcalibre1" id="CO2-1" shape="rect"></a><span class="pcalibre1">#1</span>

  @Override
  public void start() {
    EventBus bus = vertx.eventBus();
    bus.&lt;JsonObject&gt;consumer("sensor.updates", msg -&gt; {     <a class="pcalibre pcalibre1" id="CO2-2" shape="rect"></a><span class="pcalibre1">#2</span>
      JsonObject body = msg.body();     <a class="pcalibre pcalibre1" id="CO2-3" shape="rect"></a><span class="pcalibre1">#3</span>
      String id = body.getString("id");
      String temp = format.format(body.getDouble("temp"));
      logger.info("{} reports a temperature ~{}C", id, temp);   <a class="pcalibre pcalibre1" id="CO2-4" shape="rect"></a><span class="pcalibre1">#4</span>
    });
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2UgZG9u4oCZdCBuZWVkIHRoZSBmdWxsIGRvdWJsZSB2YWx1ZSwgc28gd2UgZm9ybWF0IGFsbCB0ZW1wZXJhdHVyZXMgdG8gMiBkZWNpbWFscyBzdHJpbmcgcmVwcmVzZW50YXRpb25zLgojMiBUaGUgY29uc3VtZXIgbWV0aG9kIGFsbG93cyBzdWJzY3JpYmluZyB0byBtZXNzYWdlcywgYW5kIGEgY2FsbGJhY2sgaGFuZGxlcyBhbGwgZXZlbnQtYnVzIG1lc3NhZ2VzLgojMyBUaGUgbWVzc2FnZSBwYXlsb2FkIGlzIGluIHRoZSBib2R5LgojNCBXZSBzaW1wbHkgbG9nLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="63" id="63" data-hash="f529cfccfe8ad06a52647add9103a5bc"> 
   <p>Listing 3.2 provides the implementation of the Listener verticle class. Its purpose is to log all temperature measures, so all it does is listening to messages received on the sensor.updates destination. Since the emitter in class HeatSensor uses a publish / subscribe pattern, Listener is not the only verticle that can receive the messages.</p> 
  </div> 
  <div class="readable-text scrambled" refid="64" id="64" data-hash="8bb31d12f7581660a53a1fd73319513b"> 
   <p>We did not take advantage of message headers in this example, but it is possible to use them for any meta-data that does not belong to the message body. A common header is that of an "action", to help receivers know what the message is about. For instance given a database.operations destination, we could use a action header to specify whether we intend to query the database, update an entry, store a new entry, or delete a previously stored one.</p> 
  </div> 
  <div class="readable-text" refid="65" id="65" data-hash="2430442b9a9f1d5795e5a0eed01c491d"> 
   <p>Let us now see another verticle that consumes temperature updates.</p> 
  </div> 
  <div class="readable-text" refid="66" id="66" data-hash="f613323aa1503201cf9e1836a355a0ea"> 
   <h3 class="calibre29" id="heading_id_11"><a class="pcalibre pcalibre1" id="sensor-data-verticle" shape="rect"></a>3.2.3 &nbsp;Sensor data verticle</h3> 
  </div> 
  <div class=" browsable-container listing-container" refid="67" id="67" data-hash="5fadb6f114374dda87720e4b7beecc79"> 
   <h5>Listing&nbsp;3.3.&nbsp;Sensor data verticle implementation</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class SensorData extends AbstractVerticle {
  private final HashMap&lt;String, Double&gt; lastValues = new HashMap&lt;&gt;();   <a class="pcalibre pcalibre1" id="CO3-1" shape="rect"></a><span class="pcalibre1">#1</span>

  @Override
  public void start() {     <a class="pcalibre pcalibre1" id="CO3-2" shape="rect"></a><span class="pcalibre1">#2</span>
    EventBus bus = vertx.eventBus();
    bus.consumer("sensor.updates", this::update);
    bus.consumer("sensor.average", this::average);
  }

  private void update(Message&lt;JsonObject&gt; message) {    <a class="pcalibre pcalibre1" id="CO3-3" shape="rect"></a><span class="pcalibre1">#3</span>
    JsonObject json = message.body();
    lastValues.put(json.getString("id"), json.getDouble("temp"));
  }

  private void average(Message&lt;JsonObject&gt; message) {   <a class="pcalibre pcalibre1" id="CO3-4" shape="rect"></a><span class="pcalibre1">#4</span>
    double avg = lastValues.values().stream()
      .collect(Collectors.averagingDouble(Double::doubleValue));
    JsonObject json = new JsonObject().put("average", avg);
    message.reply(json);    <a class="pcalibre pcalibre1" id="CO3-5" shape="rect"></a><span class="pcalibre1">#5</span>
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2Ugc3RvcmUgdGhlIGxhdGVzdCBtZWFzdXJlbWVudCBvZiBlYWNoIHNlbnNvciBieSBpdHMgdW5pcXVlIGlkZW50aWZpZXIuCiMyIFRoZSBzdGFydCBtZXRob2Qgb25seSBkZWNsYXJlcyAyIGV2ZW50IGJ1cyBkZXN0aW5hdGlvbiBoYW5kbGVycy4KIzMgV2hlbiBhIG5ldyBtZWFzdXJlbWVudCBpcyBiZWluZyByZWNlaXZlZCwgd2UgZXh0cmFjdCB0aGUgZGF0YSBmcm9tIHRoZSBKU09OIGJvZHkuCiM0IFRoZSBpbmNvbWluZyBtZXNzYWdlIGZvciBhdmVyYWdlIHJlcXVlc3RzIGlzIG5vdCB1c2VkLCBzbyBpdCBjYW4ganVzdCBjb250YWluIGFuIGVtcHR5IEpTT04gZG9jdW1lbnQuCiM1IFJlcGx5aW5nIHRvIGEgbWVzc2FnZSBoYXBwZW5zIHdpdGggdGhlIHJlcGx5IG1ldGhvZC4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="68" id="68" data-hash="bea65f39ca5ddb38734605928b067cc2"> 
   <p>Listing 3.3 gives the implementation of verticle class SensorData. It has 2 handlers for each destination. In one case it updates entries in a HashMap, in the other case it computes the average and responds to the message sender.</p> 
  </div> 
  <div class="readable-text scrambled" refid="69" id="69" data-hash="907dc2f70567c8cd0851594fd7340d70"> 
   <p>The next verticle is the HTTP server. It also consumes temperature updates, but also requests temperature averages to the SensorData verticle via the event-bus.</p> 
  </div> 
  <div class="readable-text" refid="70" id="70" data-hash="87ca898cb60578b2a9683cfb5c983339"> 
   <h3 class="calibre29" id="heading_id_12"><a class="pcalibre pcalibre1" id="http-server-verticle" shape="rect"></a>3.2.4 &nbsp;HTTP server verticle</h3> 
  </div> 
  <div class="readable-text scrambled" refid="71" id="71" data-hash="653d475a5b1264503b99a054efeb25b8"> 
   <p>This verticle is interesting as it listens to event-bus events, and it implements the server-sent events protocol. Let us start with the backbone of this verticle implementation.</p> 
  </div> 
  <div class="readable-text" refid="72" id="72" data-hash="e9952785922f84583c11ad8a2131a878"> 
   <h4 class="calibre30" id="heading_id_13"><a class="pcalibre pcalibre1" id="server-implementation" shape="rect"></a>Server implementation</h4> 
  </div> 
  <div class=" browsable-container listing-container" refid="73" id="73" data-hash="d7ef224d7f29cd92c7860ded1a0a9000"> 
   <h5>Listing&nbsp;3.4.&nbsp;Prologue of the HTTP server verticle implementation</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class HttpServer extends AbstractVerticle {
  @Override
  public void start() {
    vertx.createHttpServer()
      .requestHandler(this::handler)
      .listen(config().getInteger("port", 8080));   #1
  }

  private void handler(HttpServerRequest request) {
    if ("/".equals(request.path())) {
      request.response().sendFile("index.html");    #2
    } else if ("/sse".equals(request.path())) {
      sse(request);                                 #3
    } else {
      request.response().setStatusCode(404);        #4
    }
  }
// (...)
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhlIEhUVFAgc2VydmVyIHBvcnQgaXMgY29uZmlndXJhdGlvbiBkYXRhIHdpdGggODA4MCBhcyB0aGUgZGVmYXVsdCB2YWx1ZS4KIzIgVGhlIHNlbmRGaWxlIG1ldGhvZCBhbGxvd3Mgc3RyZWFtaW5nIHRoZSBjb250ZW50IG9mIGFueSBsb2NhbCBmaWxlIHRvIHRoZSBjbGllbnQuIFRoaXMgY2xvc2VzIHRoZSBjb25uZWN0aW9uIGF1dG9tYXRpY2FsbHkuCiMzIFNlcnZlci1zZW50IGV2ZW50cyB3aWxsIHVzZSB0aGUgL3NzZSByZXNvdXJjZSwgYW5kIHdlIHByb3ZpZGUgYSBtZXRob2QgZm9yIGhhbmRsaW5nIHRoZXNlIHJlcXVlc3RzLgojNCBBbnl0aGluZyBlbHNlIHRyaWdnZXJzIGEgSFRUUCA0MDQgKG5vdCBmb3VuZCku"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="74" id="74" data-hash="1d3adc138f0f20019df7a5a8baf14a9e"> 
   <p>The code in listing 3.4 is a classical example of starting a HTTP server and declaring a request handler. The handler deals with 3 cases:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="75" id="75" data-hash="053e5336c3be4a7e047c8a777563fed3"> nrevisg urx wxd polpactiina vr srborwes,<br> </li> 
   <li class="listitem readable-text scrambled" refid="76" id="76" data-hash="2742bd9bf5a97c8587ed9b691168a1fd"> voridngip s roeeuscr lkt veserr-nrzx eestnv,<br> </li> 
   <li class="listitem readable-text scrambled" refid="77" id="77" data-hash="0cecf20280db5a949678b6df0cef4021"> onndgipesr rjwq 404 rseror vlt znd erhot reueorsc rdzb.<br> </li> 
  </ol> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="78" id="78" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="79" id="79" data-hash="270c4d5da8353b906851d251034deb74"> 
     <p>Manually dispatching custom actions depending on the requested resource path and HTTP method is tedious. As we will see later the vertx-web module provides a nicer router API for conveniently declaring handlers.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="80" id="80" data-hash="3504c0aaecbf9c6e23bb831cc3d16190"> 
   <h4 class="calibre30" id="heading_id_14"><a class="pcalibre pcalibre1" id="the-web-application" shape="rect"></a>The web application</h4> 
  </div> 
  <div class="readable-text scrambled" refid="81" id="81" data-hash="9f8ccfac1a7fadf8a078fa9d6f895afa"> 
   <p>Let us now see the client-side application which is being served by the HTTP server.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="82" id="82" data-hash="f181b3b44525f8922e8691e21f938abf"> 
   <h5>Listing&nbsp;3.5.&nbsp;Web application code</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">&lt;div id="avg"&gt;&lt;/div&gt;
&lt;div id="main"&gt;&lt;/div&gt;
&lt;script language="JavaScript"&gt;
  const sse = new EventSource("/sse")   <a class="pcalibre pcalibre1" id="CO5-1" shape="rect"></a><span class="pcalibre1">#1</span>
  const main = document.getElementById("main")
  const avg = document.getElementById("avg")

  sse.addEventListener("update", (evt) =&gt; {     <a class="pcalibre pcalibre1" id="CO5-2" shape="rect"></a><span class="pcalibre1">#2</span>
    const data = JSON.parse(evt.data)           <a class="pcalibre pcalibre1" id="CO5-3" shape="rect"></a><span class="pcalibre1">#3</span>
    let div = document.getElementById(data.id);
    if (div === null) {
      div = document.createElement("div")   <a class="pcalibre pcalibre1" id="CO5-4" shape="rect"></a><span class="pcalibre1">#4</span>
      div.setAttribute("id", data.id)
      main.appendChild(div)
    }
    div.innerHTML = `&lt;strong&gt;${data.temp.toFixed(2)}&lt;/strong&gt; (&lt;em&gt;${data.id}&lt;/em&gt;)`    <a class="pcalibre pcalibre1" id="CO5-5" shape="rect"></a><span class="pcalibre1">#5</span>
  })

  sse.addEventListener("average", (evt) =&gt; {    <a class="pcalibre pcalibre1" id="CO5-6" shape="rect"></a><span class="pcalibre1">#6</span>
    const data = JSON.parse(evt.data)
    avg.innerText = `Average = ${data.average.toFixed(2)}`
  })
&lt;/script&gt;</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgRXZlbnRTb3VyY2Ugb2JqZWN0cyBkZWFsIHdpdGggc2VydmVyLXNlbnQgZXZlbnRzLgojMiBUaGlzIGNhbGxiYWNrIGxpc3RlbnMgZm9yIHNlcnZlci1zZW50IGV2ZW50IG9mIHR5cGUgdXBkYXRlLgojMyBUaGUgcmVzcG9uc2UgZGF0YSBpcyBwbGFpbiB0ZXh0LCBhbmQgc2luY2UgdGhlIHNlcnZlciB3aWxsIGJlIHNlbmRpbmcgSlNPTiB3ZSBuZWVkIHRvIHBhcnNlIGl0LgojNCBJZiB0aGUgc2Vuc29yIGRvZXNu4oCZdCBoYXZlIGEgZGl2IGZvciBkaXNwbGF5aW5nIGl0cyBkYXRhLCB0aGVuIHdlIGNyZWF0ZSBpdC4KIzUgVGhpcyB1cGRhdGVzIGEgZGl2IHRlbXBlcmF0dXJlIEhUTUwuCiM2IFRoaXMgY2FsbGJhY2sgbGlzdGVucyB0byBzZXJ2ZXItc2VudCBldmVudHMgb2YgdHlwZSBhdmVyYWdlLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="83" id="83" data-hash="0ea73016700dcddf2e4778f026a609a4"> 
   <p>The web application fits in a single HTML document given in listing 3.5 (we removed the irrelevant HTML portions such as headers and footers). The JavaScript code deals with server-sent events, and reacts to update the displayed content.</p> 
  </div> 
  <div class="readable-text scrambled" refid="84" id="84" data-hash="763944408e9630f1acd8c3fa41012229"> 
   <p>We could have used one of the many popular JavaScript frameworks, but sometimes it is also good to enjoy getting back to basics.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="85" id="85" data-hash="f35a087d0dc71beb3a7204d91c1c49e4"> 
     <h5>Note</h5> 
    </div> 
    <div class="readable-text scrambled" refid="86" id="86" data-hash="0dedbf4dc2f5264cb704a478d1f291c2"> 
     <p>You may have noticed that listing 3.5 uses a modern version of JavaScript, with arrow functions, no semicolons and string templates. This code should work as-is on any recent web browsers, and at the very least the author tested it with Mozilla Firefox 63, Safari 12 and Google Chrome 70.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="87" id="87" data-hash="2791b205d0219ef6e9d9d4866a5c30d8"> 
   <h4 class="calibre30" id="heading_id_15"><a class="pcalibre pcalibre1" id="supporting-server-sent-events" shape="rect"></a>Supporting server-sent events</h4> 
  </div> 
  <div class="readable-text scrambled" refid="88" id="88" data-hash="b0bc159d26908d1fd2cfbc27c5e955cd"> 
   <p>Let us now focus on how server-sent events work, and how they can be easily implemented with Vert.x.</p> 
  </div> 
  <div class="readable-text scrambled" refid="89" id="89" data-hash="c06eb72c39a3755378b6493194d83a3c"> 
   <p>Server-sent events are a very simple yet effective protocol for a server to push events to its clients [SSE]. The protocol is text-based, and each event is a block with an event type and some data:</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="90" id="90" data-hash="40a9d28f84ed2fab51b967d6a2b45e00"> 
   <div class="code-area-container"> 
    <pre class="code-area">event: foo
data: bar</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="91" id="91" data-hash="0c6d080cd5218a14f92240332b2844f7"> 
   <p>Each block event is separated by an empty line, so 2 successive events look like:</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="92" id="92" data-hash="e9e659bd3489b90d1dd5457a6b7747ed"> 
   <div class="code-area-container"> 
    <pre class="code-area">event: foo
data: abc

event: bar
data: 123</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class="readable-text" refid="93" id="93" data-hash="d7be9c0de2f440ccf9131316c702e5ac"> 
   <p>Implementing server-sent events with Vert.x is very easy.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="94" id="94" data-hash="1a45c72906fc691bc41f25caf60b4d49"> 
   <h5>Listing&nbsp;3.6.&nbsp;Supporting server-sent events</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">private void sse(HttpServerRequest request) {
  HttpServerResponse response = request.response();
  response
    .putHeader("Content-Type", "text/event-stream")     <a class="pcalibre pcalibre1" id="CO6-1" shape="rect"></a><span class="pcalibre1">#1</span>
    .putHeader("Cache-Control", "no-cache")             <a class="pcalibre pcalibre1" id="CO6-2" shape="rect"></a><span class="pcalibre1">#2</span>
    .setChunked(true);

  MessageConsumer&lt;JsonObject&gt; consumer = vertx.eventBus().consumer("sensor.updates");   <a class="pcalibre pcalibre1" id="CO6-3" shape="rect"></a><span class="pcalibre1">#3</span>
  consumer.handler(msg -&gt; {
    response.write("event: update\n");  <a class="pcalibre pcalibre1" id="CO6-4" shape="rect"></a><span class="pcalibre1">#4</span>
    response.write("data: " + msg.body().encode() + "\n\n");
  });

  TimeoutStream ticks = vertx.periodicStream(1000); <a class="pcalibre pcalibre1" id="CO6-5" shape="rect"></a><span class="pcalibre1">#5</span>
  ticks.handler(id -&gt; {
    vertx.eventBus().&lt;JsonObject&gt;request("sensor.average", "", reply -&gt; {  <a class="pcalibre pcalibre1" id="CO6-6" shape="rect"></a><span class="pcalibre1">#6</span>
      if (reply.succeeded()) {
        response.write("event: average\n");
        response.write("data: " + reply.result().body().encode() + "\n\n");
      }
    });
  });

  response.endHandler(v -&gt; {    <a class="pcalibre pcalibre1" id="CO6-7" shape="rect"></a><span class="pcalibre1">#7</span>
    consumer.unregister();
    ticks.cancel();
  });
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhlIHRleHQvZXZlbnQtc3RyZWFtIE1JTUUgdHlwZSBzaGFsbCBiZSBzcGVjaWZpZWQgZm9yIHNlcnZlci1zZW50IGV2ZW50cy4KIzIgU2luY2UgdGhpcyBpcyBhIGxpdmUgc3RyZWFtLCB3ZSBuZWVkIHRvIHByZXZlbnQgYnJvd3NlcnMgYW5kIHByb3hpZXMgZnJvbSBjYWNoaW5nIGl0LgojMyBXZSBjYWxsIGNvbnN1bWVyIHdpdGhvdXQgYSBoYW5kbGVyLCBhcyB3ZSBuZWVkIGFuIG9iamVjdCB0byBjYW5jZWwgdGhlIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBjbGllbnQgZGlzY29ubmVjdHMuCiM0IFNlbmRpbmcgZXZlbnQgYmxvY2tzIGlzIGp1c3Qgc2VuZGluZyB0ZXh0LgojNSBXZSB1cGRhdGUgdGhlIGF2ZXJhZ2UgZXZlcnkgc2Vjb25kLCBzbyB3ZSBuZWVkIGEgcGVyaW9kaWMgdGltZXIuIFNpbmNlIGl0IG5lZWRzIGNhbmNlbGxhdGlvbiwgd2UgYWxzbyB1c2UgYSBmb3JtIHdpdGhvdXQgaGFuZGxlciB0byBnZXQgYW4gb2JqZWN0LgojNiByZXF1ZXN0IHNlbmRzIGEgbWVzc2FnZSB0aGF0IGV4cGVjdHMgYSByZXNwb25zZS4gVGhlIHJlcGx5IGlzIGFuIGFzeW5jaHJvbm91cyBvYmplY3QsIGFzIGl0IG1heSBoYXZlIGZhaWxlZC4KIzcgV2hlbiB0aGUgY2xpZW50IGRpc2Nvbm5lY3RzIChvciByZWZyZXNoZXMgdGhlIHBhZ2UhKSB0aGVuIHdlIG5lZWQgdG8gdW4tcmVnaXN0ZXIgdGhlIGV2ZW50LWJ1cyBtZXNzYWdlIGNvbnN1bWVyLCBhbmQgY2FuY2VsIHRoZSBwZXJpb2RpYyB0YXNrIHRoYXQgY29tcHV0ZXMgYXZlcmFnZXMu"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="95" id="95" data-hash="b77db866bf43cbc9814f8d0d92682b2f"> 
   <p>Listing 3.6 provides the implementation of the sse method that deals with HTTP requests to the /sse resource. It declares a consumer per HTTP request for temperature updates, and pushes new events. It also declares a periodic task to query the SensorData verticle and maintain the average in a request-reply manner.</p> 
  </div> 
  <div class="readable-text scrambled" refid="96" id="96" data-hash="cb5f634cd0cc7b0c61fea9f4fefe772f"> 
   <p>Since these 2 handlers are per HTTP request, we need to be able to stop them when the connection is lost. This may happen because a web browser tab is closed, or simply on page reloads. To do that we obtain stream objects and for each we declare a handler, just like we would to with the forms that accept callbacks. We will see in the next chapter how to deal with stream objects, and when they are useful.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="97" id="97" data-hash="6fd16bbb30a03453d1d892f9379b524b"> 
   <h5>Listing&nbsp;3.7.&nbsp;Stream of SSE events using HTTPie</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">$ http http://localhost:8080/sse --stream  #1
HTTP/1.1 200 OK
Cache-Control: no-cache
Content-Type: text/event-stream
Transfer-Encoding: chunked

event: average  #2
data: {"average":21.132465880152044}  #3

event: update
data: {"id":"3fa8321d-7600-42d3-b114-9fb6cdab7ecd","temp":21.043921061475107}

event: update
data: {"id":"8626e13f-9114-4f7d-acc3-bd60b00f3028","temp":21.47111113365458}

event: average
data: {"average":21.123126848463464}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgVGhlIC0tc3RyZWFtIGZsYWcgYWxsb3dzIHN0cmVhbWluZyB0aGUgcmVzcG9uc2UgdG8gdGhlIGNvbnNvbGUgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgdGhlIHNlcnZlciB0byBlbmQgdGhlIGNvbm5lY3Rpb24uCiMyIEVhY2ggZXZlbnQgaGFzIGEgdHlwZS4KIzMgU2luY2UgSlNPTiBpcyBqdXN0IHRleHQsIGl0IHRyYW5zcG9ydHMgd2VsbCBhcyBldmVudCBkYXRhLg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="98" id="98" data-hash="56e58078997c1d7d9f23a53faaafd9b2"> 
   <p>We may also use a command-line tool such as HTTPie or curl against the application running to see the event stream, as in listing 3.7.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="99" id="99" data-hash="bf26d85e1aec3d63e66619eaa6943458"> 
     <h5>Warning</h5> 
    </div> 
    <div class="readable-text scrambled" refid="100" id="100" data-hash="241a4f9f5a82f5428c0df6c1b05b9a64"> 
     <p>At the time of writing server-sent events were supported by all major web browsers except those from Microsoft. There exists some JavaScript polyfills to provide the missing functionality to these browsers, albeit with some limitations.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="101" id="101" data-hash="060ae1e801801df8ea76d55a1978783e"> 
   <h3 class="calibre29" id="heading_id_16"><a class="pcalibre pcalibre1" id="bootstrapping-the-application" shape="rect"></a>3.2.5 &nbsp;Bootstrapping the application</h3> 
  </div> 
  <div class="readable-text scrambled" refid="102" id="102" data-hash="f9b8513f5621daa0e91c2ed01528c595"> 
   <p>Now that we have all verticles ready, let us assemble them as a Vert.x application.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="103" id="103" data-hash="dd07f1987afbcc33ddfc2192ac10b022"> 
   <h5>Listing&nbsp;3.8.&nbsp;Main class to bootstrap the application</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class Main {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle("chapter3.HeatSensor", new DeploymentOptions().setInstances(4));   #1
    vertx.deployVerticle("chapter3.Listener");  #2
    vertx.deployVerticle("chapter3.SensorData");
    vertx.deployVerticle("chapter3.HttpServer");
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2Ugc3RhcnQgNCAic2Vuc29ycyIuCiMyIFdlIGFyZSB1c2luZyB0aGUgdmFyaWFudHMgb2YgZGVwbG95VmVydGljbGUgdGhhdCB1c2UgcmVmbGVjdGlvbiB0byBpbnN0YW50aWF0ZSB0aGUgdmVydGljbGUgY2xhc3Nlcy4="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="104" id="104" data-hash="75567f3151006d2d0f22fbf2cfaaa5fa"> 
   <p>Listing 3.8 gives a main class for bootstrapping the application. It deploys 4 sensor verticles, and 1 instance of each other verticle.</p> 
  </div> 
  <div class="readable-text scrambled" refid="105" id="105" data-hash="8088fbb264c6e97cbcffa19772f1ea10"> 
   <p>Running the main method of this class allows connecting with a web browser to localhost:8080/ You should then see a graphical interface similar to that of figure 3.4, with continuous live updates. The console logs shall also display temperature updates.</p> 
  </div> 
  <div class="readable-text" refid="106" id="106" data-hash="21b2be668781575e8d11d503323f9e1c"> 
   <h2 class="calibre17" id="heading_id_17"><a class="pcalibre pcalibre1" id="clustering-and-the-distributed-event-bus" shape="rect"></a>3.3 &nbsp;Clustering and the distributed event-bus</h2> 
  </div> 
  <div class="readable-text scrambled" refid="107" id="107" data-hash="b984793a5439e88b2cfc5e0d8bed60a9"> 
   <p>Our usage of the event-bus so far has been local: all communications happened within the same JVM process.</p> 
  </div> 
  <div class="readable-text scrambled" refid="108" id="108" data-hash="3ffcad356fa3770466a17ba56fda30e3"> 
   <p>What is even more interesting is to use the Vert.x clustering, and benefit from a distributed event-bus.</p> 
  </div> 
  <div class="readable-text" refid="109" id="109" data-hash="7af98667b205a8d46e72cde6743602b5"> 
   <h3 class="calibre29" id="heading_id_18"><a class="pcalibre pcalibre1" id="clustering-in-vert-x" shape="rect"></a>3.3.1 &nbsp;Clustering in Vert.x</h3> 
  </div> 
  <div class="browsable-container figure-container" refid="110" id="110" data-hash="1c99363ce75efb0361723ab154e09a8d"> 
   <h5 id="clustering">Figure&nbsp;3.6.&nbsp;Overview of the Vert.x clustering</h5> 
   <img alt="clustering" class="calibre7" src="ponge/v-10/Figures/clustering.png" width="1182" loading="lazy" height="742" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="111" id="111" data-hash="d0b8e63c9f3d4fadb857597b81034835"> 
   <p>Vert.x applications can run in clustering mode where a set of Vert.x application nodes can work together over the network. They may be node instances of the same application and have the same set of deployed verticles, but this is not a requirement. Some nodes can have a set of verticles A, while others have a set of verticles B.</p> 
  </div> 
  <div class="readable-text scrambled" refid="112" id="112" data-hash="35edbdce34f872e44c821e62af9e9731"> 
   <p>Figure 3.6 gives an overview of the Vert.x clustering. A cluster manager provides the following set of functionalities.</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="113" id="113" data-hash="e549302e2ae4baea61c49a3ff1ecd2b9"> Nddtk eerhisbmmp qnc dicyovesr wallo rcvieosgind kwn enods, ingimanniat vpr jzrf kl cnterur sonde, nys cedtte kwnd eodns ppisderaa.<br> </li> 
   <li class="listitem readable-text scrambled" refid="114" id="114" data-hash="ea310ad356bb8b5d22dfd143e06dadef"> Sdrahe ccrg llaow mgza ncy orscnute vr ky amadtinine ultcsre-jqxw, cv rcdr ffs odsne hresa rob mkcs luesva. Nrtbiuteisd solkc kts selfuu ltv kmcx ormfs el ocnidotrioan eebtwne osned.<br> </li> 
   <li class="listitem readable-text scrambled" refid="115" id="115" data-hash="e2772caf7dbe8fbaa69cc5a5e7a3e450"> Seusrbbcsri yotgoopl lwsoal gwninok swrq etvne-pzg nstinotiased pvsz nopk yac ettniser rx. Yjcb jc flsueu ltx tniifycfele dpaigscnith sgsmaees xoxt qrk eruidtisbtd eevtn-ghz. Jl vmvc oknb zcu nk csumeonr nv odsnentiiat <code class="code">a.b.c</code>, ronq ereht cj vn pnoit einsndg tenesv tkml rrsb netsaoinidt vr brsr npvv.<br> </li> 
  </ol> 
  <div class="readable-text scrambled" refid="116" id="116" data-hash="2c31c1a1379b1311468ccb95b6968e35"> 
   <p>There are several cluster manager implementations for Vert.x based on Hazelcast, Infinispan, Apache Ignite and Apache Zookeeper. Historically Hazelcast was the cluster manager for Vert.x, then other engines were added. They all support the same Vert.x clustering abstractions for membership, shared data and event-bus message passing. They are all functionally equivalent, so you will have to choose one depending on your needs and constraints. If you have no idea which one to pick, then I would recommend going with Hazelcast which is a good default.</p> 
  </div> 
  <div class="readable-text scrambled" refid="117" id="117" data-hash="680f06d3b4eb08b7186750f70a5156b3"> 
   <p>Finally as shown in figure 3.6, the event-bus communications between nodes happen through direct TCP connections, using a custom protocol. When a node sends a message to a destination, then it checks the subscribers topology with the cluster manager, and dispatches the message to the nodes that have subscribers for that destination.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="118" id="118" data-hash="2785d1bb276aea9206d8155b146d49ee"> 
     <h5>What cluster manager should you use?</h5> 
    </div> 
    <div class="readable-text scrambled" refid="119" id="119" data-hash="615e8722f402c2fa172959503138ddff"> 
     <p>There is no good answer to the question of what cluster manager you should be using. It very much depends on whether you need special integration with one library, and also in what type of environment you need to deploy. If say, you need to use the Infinispan APIs in your code and not just Infinispan as the cluster manager engine for Vert.x, then you should go with Infinispan to cover both needs.</p> 
    </div> 
    <div class="readable-text scrambled" refid="120" id="120" data-hash="b040ff316c4868804f7dc16309ce1efe"> 
     <p>You should also consider your deployment environment. If you deploy to some environment where Apache Zookeeper is being used, then perhaps it is a good choice to also rely on it for the Vert.x cluster manager.</p> 
    </div> 
    <div class="readable-text scrambled" refid="121" id="121" data-hash="378c1af84b66245b04e8945c374ea880"> 
     <p>By default for some cluster managers use multicast communications for node discovery, which may be disabled on some networks, especially those found in containerized environments like Kubernetes. In this case you will need to configure the cluster manager to work in these environments.</p> 
    </div> 
    <div class="readable-text scrambled" refid="122" id="122" data-hash="e71f90477bcde005d79da0979bc9cfc1"> 
     <p>As mentioned earlier: in case of doubt choose Hazelcast and check the project documentation for specific network configuration like when deploying to Kubernetes. You can always later change to another cluster manager implementation.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="123" id="123" data-hash="0b2b8a655f9d9df0f8842ea4dd92b441"> 
   <h3 class="calibre29" id="heading_id_19"><a class="pcalibre pcalibre1" id="from-event-bus-to-distributed-event-bus" shape="rect"></a>3.3.2 &nbsp;From event-bus to distributed event-bus</h3> 
  </div> 
  <div class="readable-text scrambled" refid="124" id="124" data-hash="628b052a9f0930eab8d1666a9bf07cc4"> 
   <p>Let us get back to the heat sensors application that we developed earlier in this chapter. Moving to a distributed event-bus is transparent for the verticles.</p> 
  </div> 
  <div class="browsable-container figure-container" refid="125" id="125" data-hash="df46714401ff67b6302a7f4e37811cd1"> 
   <h5 id="clustered-app">Figure&nbsp;3.7.&nbsp;Clustered application overview</h5> 
   <img alt="clustered app" class="calibre7" src="ponge/v-10/Figures/clustered-app.png" width="1012" loading="lazy" height="546" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="126" id="126" data-hash="031d2558f878a233e96643a37c8802da"> 
   <p>We are going to prepare 2 main classes with different verticle deployments, as illustrated in figure 3.7:</p> 
  </div> 
  <ol class="orderedlist"> 
   <li class="listitem readable-text scrambled" refid="127" id="127" data-hash="bc67662449be73b8c56857bd81bbd58f"> 4 senctnasi kl <code class="code">HeatSensor</code>, nyc 1 nsicenat vl <code class="code">HttpServer</code> kn rtvb 8080, nsu<br> </li> 
   <li class="listitem readable-text scrambled" refid="128" id="128" data-hash="cbbbaf6146b346737e6197c85ecc4257"> 4 sanistnce le <code class="code">HeatSensor</code>, 1 tniceans xl <code class="code">Listener</code>, 1 niaencts lk <code class="code">SensorData</code>, ncy 1 anstncei el <code class="code">HttpServer</code> kn edtr 8081 (ck yde ssn ytn zpn rrzx rj en rgk acmx grcv).<br> </li> 
  </ol> 
  <div class="readable-text scrambled" refid="129" id="129" data-hash="f9d718917a1e9ecf647f1e1abae0e04a"> 
   <p>The goal is to show that by launching 1 instance of each deployment in clustering mode, verticles communicate just as if they were running within the same JVM process. Connecting with a web browser to either of the instance will give the same view to the 8 sensors data. Similarly the Listener verticle on the second instance will get temperature updates from the first instance.</p> 
  </div> 
  <div class="readable-text scrambled" refid="130" id="130" data-hash="16665bbd08a6284720d506248cea08ac"> 
   <p>We will use Infinispan as the cluster manager, but you can equally use another one. Supposing your project is built with Gradle, you need to add vertx-infinispan as a dependency:</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="131" id="131" data-hash="1d993418e60af9f0c036eee680390ece"> 
   <div class="code-area-container"> 
    <pre class="code-area">implementation 'io.vertx:vertx-infinispan:version'</pre> 
    <div class="code-annotations-overlay-container" data-annotations=""></div> 
   </div> 
  </div> 
  <div class=" browsable-container listing-container" refid="132" id="132" data-hash="cbff98c35de80c28d7fd9514ea841a57"> 
   <h5>Listing&nbsp;3.9.&nbsp;Code of the main class for the first instance</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class FirstInstance {
  private static final Logger logger = LoggerFactory.getLogger(FirstInstance.class);

  public static void main(String[] args) {
    Vertx.clusteredVertx(new VertxOptions(), ar -&gt; {    #1
      if (ar.succeeded()) {
        logger.info("First instance has been started");
        Vertx vertx = ar.result();  #2
        vertx.deployVerticle("chapter3.HeatSensor", new DeploymentOptions().setInstances(4));
        vertx.deployVerticle("chapter3.HttpServer");
      } else {
        logger.error("Could not start", ar.cause());    #3
      }
    });
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgU3RhcnRpbmcgYSBjbHVzdGVyZWQgVmVydC54IGFwcGxpY2F0aW9uIGlzIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uCiMyIFVwb24gc3VjY2Vzcywgd2UgcmV0cmlldmUgdGhlIFZlcnR4IGluc3RhbmNlLgojMyBBIHBvdGVudGlhbCBjYXVzZSBvZiBmYWlsdXJlIGNvdWxkIGJlIHRoZSBhYnNlbmNlIG9mIGEgY2x1c3RlciBtYW5hZ2VyIGxpYnJhcnku"></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="133" id="133" data-hash="d0ca36b2e1ac793087909171c758b3fb"> 
   <p>Listing 3.9 gives the implementation of the main class FirstInstance that we can use for starting one node that doesn’t deploy all of the application verticles. As we can see starting an application in clustered mode requires calling the clusteredVertx method. The remainder is just classic verticle deployment.</p> 
  </div> 
  <div class=" browsable-container listing-container" refid="134" id="134" data-hash="bf724f179d8c6fae0194b72fba7d4b01"> 
   <h5>Listing&nbsp;3.10.&nbsp;Code of the main class for the second instance</h5> 
   <div class="code-area-container"> 
    <pre class="code-area">public class SecondInstance extends AbstractVerticle {
  private static final Logger logger = LoggerFactory.getLogger(SecondInstance.class);

  public static void main(String[] args) {
    Vertx.clusteredVertx(new VertxOptions(), ar -&gt; {
      if (ar.succeeded()) {
        logger.info("Second instance has been started");
        Vertx vertx = ar.result();
        vertx.deployVerticle("chapter3.HeatSensor", new DeploymentOptions().setInstances(4));
        vertx.deployVerticle("chapter3.Listener");
        vertx.deployVerticle("chapter3.SensorData");
        JsonObject conf = new JsonObject().put("port", 8081);   #1
        vertx.deployVerticle("chapter3.HttpServer", new DeploymentOptions().setConfig(conf));
      } else {
        logger.error("Could not start", ar.cause());
      }
    });
  }
}</pre> 
    <div class="code-annotations-overlay-container" data-annotations="IzEgV2UgdXNlIGEgZGlmZmVyZW50IHBvcnQgc28geW91IGNhbiBzdGFydCBib3RoIGluc3RhbmNlcyBvbiB0aGUgc2FtZSBob3N0Lg=="></div> 
   </div> 
  </div> 
  <div class="readable-text scrambled" refid="135" id="135" data-hash="1066172f4fb548a23e0a24212a16718c"> 
   <p>The code of the second instance main method is very similar and given in listing 3.10.</p> 
  </div> 
  <div class="readable-text scrambled" refid="136" id="136" data-hash="19e0effb19436902edf0ef0e2b8bc2e1"> 
   <p>Both main classes can be run on the same host, and the 2 instances discover each other. Indeed by default the Vert.x Infinispan cluster manager is configured to perform discovery using network broadcast, hence the 2 instances discover themselves when run on the same machine. You can also do the experiment and use 2 machines on the same network.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="137" id="137" data-hash="bf26d85e1aec3d63e66619eaa6943458"> 
     <h5>Warning</h5> 
    </div> 
    <div class="readable-text scrambled" refid="138" id="138" data-hash="72a99cc21e396f492e4563718a2a3214"> 
     <p>Network broadcast rarely works in cloud environments and many data centers. In these cases the cluster manager needs to be configured to use other discovery and group membership protocols. In the case of Infinispan the documentation has specific details at [InfinispanCloud].</p> 
    </div> 
   </div> 
  </div> 
  <div class="browsable-container figure-container" refid="139" id="139" data-hash="42454e0806995a479604567f7960320f"> 
   <h5 id="clustered-app-run">Figure&nbsp;3.8.&nbsp;Screenshot of the application running in clustered mode</h5> 
   <img alt="clustered app run" class="calibre7" src="ponge/v-10/Figures/clustered-app-run.png" width="1053" loading="lazy" height="640" onerror="fallbackToImageSrcPlaceholder(this)"> 
  </div> 
  <div class="readable-text scrambled" refid="140" id="140" data-hash="99416709589e5a255cd23b1a0d8b24de"> 
   <p>Figure 3.8 shows the application running with 1 browser connected to the instance with port 8080, another browser connected to the second instance with port 8081, and we see logs from the Listener verticle in the background. As we can see, both instances display events from the 8 sensors, and the first instance has its average temperature updated so it can interact with the SensorData verticle on the second instance.</p> 
  </div> 
  <div class="readable-text scrambled" refid="141" id="141" data-hash="ba78b0c96a195002174e8410d70f1368"> 
   <p>The distributed event-bus is an interesting tool as it is transparent to the verticles.</p> 
  </div> 
  <div class="tip"> 
   <div class=" callout-container caution-container"> 
    <div class="readable-text" refid="142" id="142" data-hash="5c622e940054ac4ab45712e2d7b5d25d"> 
     <h5>Tip</h5> 
    </div> 
    <div class="readable-text scrambled" refid="143" id="143" data-hash="9ab5193de492bb1ae628ec3186b1e482"> 
     <p>The event-bus API has localConsumer methods for declaring message handlers that only work locally when running with clustering. For instance a consumer for destination a.b.c will not receive messages sent to that destination from another instance in the cluster.</p> 
    </div> 
   </div> 
  </div> 
  <div class="readable-text" refid="144" id="144" data-hash="11d7676848db6638aab37330b7d10e3e"> 
   <p>The next chapter discusses asynchronous data and event streams.</p> 
  </div> 
  <div class="readable-text" refid="145" id="145" data-hash="1cb0e58a9b2b9e92d624befcbe6d4f01"> 
   <h2 class="calibre17" id="heading_id_20"><a class="pcalibre pcalibre1" id="summary" shape="rect"></a>3.4 &nbsp;Summary</h2> 
  </div> 
  <ul class="itemizedlist"> 
   <li class="listitem readable-text" refid="146" id="146" data-hash="598f446729cef00f7b08a65ef2c9623b"> The event-bus is the preferred way for verticles to communicate, and it uses asynchronous message passing.<br> </li> 
   <li class="listitem readable-text" refid="147" id="147" data-hash="bdde4c28d9ebb817efd58ae4d6c53710"> The event-bus implements both publish / subscribe ("one to many") and point-to-point ("many to one") communications.<br> </li> 
   <li class="listitem readable-text" refid="148" id="148" data-hash="7a864526eb7f95ff39bb00becee683c3"> While it looks like a traditional message broker, the event-bus does not provide durability guarantees so it must only be used for transient data.<br> </li> 
   <li class="listitem readable-text" refid="149" id="149" data-hash="2ec9cbdd5439e9e0a3870ba55b6440aa"> Clustering allows networked instances to communicate over the distributed event-bus in a transparent fashion.<br> </li> 
  </ul> 
  <div class="readable-text" refid="150" id="150" data-hash="2f1d5274edd45303490f6bfd23f27c3f"> 
   <h2 class="calibre17" id="heading_id_21"><a class="pcalibre pcalibre1" id="references" shape="rect"></a>3.5 &nbsp;References</h2> 
  </div> 
  <div class="bibliodiv"> 
   <div class="bibliomixed"> <a class="pcalibre" id="d5e1852" shape="rect"></a> 
    <div class="readable-text" refid="151" id="151" data-hash="d3b623cf6ac1190ca5f1c4fc0bb5f5fc"> 
     <p><span class="bibliomisc"><a class="pcalibre" id="SSE" shape="rect"></a>[SSE] Ian Hickson. Server-Sent Events. 03 February 2015. W3C Recommendation. <a class="pcalibre3 pcalibre" href="https://www.w3.org/TR/eventsource/" shape="rect">www.w3.org/TR/eventsource/</a></span></p> 
    </div> 
   </div> 
   <div class="bibliomixed"> <a class="pcalibre" id="d5e1856" shape="rect"></a> 
    <div class="readable-text" refid="152" id="152" data-hash="08f7e072d7ca4f4b2248294731ce6a03"> 
     <p><span class="bibliomisc"><a class="pcalibre" id="KafkaInAction" shape="rect"></a>[KafkaInAction]. Dylan Scott. Kafka in Action. 2019. Manning Publications. ISBN 9781617295232.</span></p> 
    </div> 
   </div> 
   <div class="bibliomixed"> <a class="pcalibre" id="d5e1859" shape="rect"></a> 
    <div class="readable-text" refid="153" id="153" data-hash="6a964958679eb4d1af854abbd1c99991"> 
     <p><span class="bibliomisc"><a class="pcalibre" id="InfinispanCloud" shape="rect"></a>[InfinispanCloud]. Infinispan documentation on cloud services configuration. Retrieved at <a class="pcalibre3 pcalibre" href="http://infinispan.org/docs/stable/user_guide/user_guide.html#cloud_services" shape="rect">infinispan.org/docs/stable/user_guide/user_guide.html#cloud_services</a></span></p> 
    </div> 
   </div> 
  </div>
 </body>
</html>