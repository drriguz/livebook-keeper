<p>We will see in the last chapter of part 2 how to experiment with &quot;what happens when things go wrong&quot;, and discuss possible solutions to keep services responsive. You could be tempted to enforce strict timeouts on all calls to other services (including databases), or use <em class="calibre10">circuit-breakers</em> (more on that in the last chapter) everywhere but a more analytic approach will help you see what solution to use, if any, and when. It is also important to see failure in the light of a service functional requirements and application domain: the response to failure may not always be an error. For instance if we canâ€™t get the latest temperature update from a sensor, then we may serve the last known value, and attach a timestamp to it so the requester has all the necessary context attached to the data.</p>